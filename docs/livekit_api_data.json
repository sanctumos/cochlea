{
  "modules": {
    "livekit": {
      "name": "livekit",
      "docstring": "No documentation available",
      "file": null,
      "classes": {},
      "functions": {},
      "constants": {},
      "submodules": [
        "livekit.agents",
        "livekit.api",
        "livekit.plugins",
        "livekit.protocol",
        "livekit.rtc"
      ]
    },
    "livekit.agents": {
      "name": "livekit.agents",
      "docstring": "LiveKit Agents for Python\n\nSee [https://docs.livekit.io/agents/](https://docs.livekit.io/agents/) for quickstarts,\ndocumentation, and examples.",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\agents\\__init__.py",
      "classes": {
        "APIConnectOptions": {
          "name": "APIConnectOptions",
          "docstring": "APIConnectOptions(max_retry: int = 3, retry_interval: float = 2.0, timeout: float = 10.0)",
          "module": "livekit.agents.types",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "APIConnectionError": {
          "name": "APIConnectionError",
          "docstring": "Raised when an API request failed due to a connection error.",
          "module": "livekit.agents._exceptions",
          "bases": [
            "APIError"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "APIError": {
          "name": "APIError",
          "docstring": "Raised when an API request failed.\nThis is used on our TTS/STT/LLM plugins.",
          "module": "livekit.agents._exceptions",
          "bases": [
            "Exception"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "APIStatusError": {
          "name": "APIStatusError",
          "docstring": "Raised when an API response has a status code of 4xx or 5xx.",
          "module": "livekit.agents._exceptions",
          "bases": [
            "APIError"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "APITimeoutError": {
          "name": "APITimeoutError",
          "docstring": "Raised when an API request timed out.",
          "module": "livekit.agents._exceptions",
          "bases": [
            "APIConnectionError"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Agent": {
          "name": "Agent",
          "docstring": "No documentation available",
          "module": "livekit.agents.voice.agent",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AgentSession": {
          "name": "AgentSession",
          "docstring": "Abstract base class for generic types.\n\nOn Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::\n\n    class Mapping[KT, VT]:\n        def __getitem__(self, key: KT) -> VT:\n            ...\n        # Etc.\n\nOn older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.\n\nAfter a class has been declared to be generic, it can then be used as\nfollows::\n\n    def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n        try:\n            return mapping[key]\n        except KeyError:\n            return default",
          "module": "livekit.agents.voice.agent_session",
          "bases": [
            "EventEmitter",
            "Generic"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AgentStateChangedEvent": {
          "name": "AgentStateChangedEvent",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.voice.events",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AssignmentTimeoutError": {
          "name": "AssignmentTimeoutError",
          "docstring": "Raised when accepting a job but not receiving an assignment within the specified timeout.\nThe server may have chosen another worker to handle this job.",
          "module": "livekit.agents._exceptions",
          "bases": [
            "Exception"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AudioConfig": {
          "name": "AudioConfig",
          "docstring": "Definition for the audio to be played in the background\n\nArgs:\n    volume: The volume of the audio (0.0-1.0)\n    probability: The probability of the audio being played, when multiple\n        AudioConfigs are provided (0.0-1.0)",
          "module": "livekit.agents.voice.background_audio",
          "bases": [
            "tuple"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AutoSubscribe": {
          "name": "AutoSubscribe",
          "docstring": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to 'utf-8'.\nerrors defaults to 'strict'.",
          "module": "livekit.agents.job",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "BackgroundAudioPlayer": {
          "name": "BackgroundAudioPlayer",
          "docstring": "No documentation available",
          "module": "livekit.agents.voice.background_audio",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "BuiltinAudioClip": {
          "name": "BuiltinAudioClip",
          "docstring": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
          "module": "livekit.agents.voice.background_audio",
          "bases": [
            "Enum"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ChatContext": {
          "name": "ChatContext",
          "docstring": "No documentation available",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "object"
          ],
          "methods": {
            "empty": {
              "name": "empty",
              "docstring": "No documentation available",
              "signature": "() -> 'ChatContext'",
              "parameters": [],
              "return_annotation": "ChatContext",
              "module": "livekit.agents.llm.chat_context"
            },
            "from_dict": {
              "name": "from_dict",
              "docstring": "No documentation available",
              "signature": "(data: 'dict[str, Any]') -> 'ChatContext'",
              "parameters": [
                {
                  "name": "data",
                  "annotation": "dict[str, Any]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "ChatContext",
              "module": "livekit.agents.llm.chat_context"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ChatMessage": {
          "name": "ChatMessage",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CloseEvent": {
          "name": "CloseEvent",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.voice.events",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ConversationItemAddedEvent": {
          "name": "ConversationItemAddedEvent",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.voice.events",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ErrorEvent": {
          "name": "ErrorEvent",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.voice.events",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FunctionCall": {
          "name": "FunctionCall",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FunctionCallOutput": {
          "name": "FunctionCallOutput",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FunctionTool": {
          "name": "FunctionTool",
          "docstring": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto[T](Protocol):\n        def meth(self) -> T:\n            ...",
          "module": "livekit.agents.llm.tool_context",
          "bases": [
            "Protocol"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "JobContext": {
          "name": "JobContext",
          "docstring": "No documentation available",
          "module": "livekit.agents.job",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "JobExecutorType": {
          "name": "JobExecutorType",
          "docstring": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
          "module": "livekit.agents.job",
          "bases": [
            "Enum"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "JobProcess": {
          "name": "JobProcess",
          "docstring": "No documentation available",
          "module": "livekit.agents.job",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "JobRequest": {
          "name": "JobRequest",
          "docstring": "No documentation available",
          "module": "livekit.agents.job",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "MetricsCollectedEvent": {
          "name": "MetricsCollectedEvent",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.voice.events",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ModelSettings": {
          "name": "ModelSettings",
          "docstring": "ModelSettings(tool_choice: 'NotGivenOr[llm.ToolChoice]' = NOT_GIVEN)",
          "module": "livekit.agents.voice.agent",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "NotGiven": {
          "name": "NotGiven",
          "docstring": "No documentation available",
          "module": "livekit.agents.types",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Plugin": {
          "name": "Plugin",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.plugin",
          "bases": [
            "ABC"
          ],
          "methods": {
            "register_plugin": {
              "name": "register_plugin",
              "docstring": "No documentation available",
              "signature": "(plugin: 'Plugin') -> 'None'",
              "parameters": [
                {
                  "name": "plugin",
                  "annotation": "Plugin",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "livekit.agents.plugin"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RoomIO": {
          "name": "RoomIO",
          "docstring": "No documentation available",
          "module": "livekit.agents.voice.room_io.room_io",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RoomInputOptions": {
          "name": "RoomInputOptions",
          "docstring": "RoomInputOptions(text_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, audio_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, video_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, audio_sample_rate: 'int' = 24000, audio_num_channels: 'int' = 1, noise_cancellation: 'rtc.NoiseCancellationOptions | None' = None, text_input_cb: 'TextInputCallback' = <function _default_text_input_cb at 0x00000192A8171F80>, participant_kinds: 'NotGivenOr[list[rtc.ParticipantKind.ValueType]]' = NOT_GIVEN, participant_identity: 'NotGivenOr[str]' = NOT_GIVEN, pre_connect_audio: 'bool' = True, pre_connect_audio_timeout: 'float' = 3.0, close_on_disconnect: 'bool' = True)",
          "module": "livekit.agents.voice.room_io.room_io",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RoomOutputOptions": {
          "name": "RoomOutputOptions",
          "docstring": "RoomOutputOptions(transcription_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, audio_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, audio_sample_rate: 'int' = 24000, audio_num_channels: 'int' = 1, audio_publish_options: 'rtc.TrackPublishOptions' = <factory>, sync_transcription: 'NotGivenOr[bool]' = NOT_GIVEN)",
          "module": "livekit.agents.voice.room_io.room_io",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RunContext": {
          "name": "RunContext",
          "docstring": "Abstract base class for generic types.\n\nOn Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::\n\n    class Mapping[KT, VT]:\n        def __getitem__(self, key: KT) -> VT:\n            ...\n        # Etc.\n\nOn older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.\n\nAfter a class has been declared to be generic, it can then be used as\nfollows::\n\n    def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n        try:\n            return mapping[key]\n        except KeyError:\n            return default",
          "module": "livekit.agents.voice.events",
          "bases": [
            "Generic"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SimulateJobInfo": {
          "name": "SimulateJobInfo",
          "docstring": "SimulateJobInfo(room: 'str', participant_identity: 'str | None' = None)",
          "module": "livekit.agents.worker",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SpeechCreatedEvent": {
          "name": "SpeechCreatedEvent",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.voice.events",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StopResponse": {
          "name": "StopResponse",
          "docstring": "Common base class for all non-exit exceptions.",
          "module": "livekit.agents.llm.tool_context",
          "bases": [
            "Exception"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ToolError": {
          "name": "ToolError",
          "docstring": "Common base class for all non-exit exceptions.",
          "module": "livekit.agents.llm.tool_context",
          "bases": [
            "Exception"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UserInputTranscribedEvent": {
          "name": "UserInputTranscribedEvent",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.voice.events",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UserStateChangedEvent": {
          "name": "UserStateChangedEvent",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.voice.events",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Worker": {
          "name": "Worker",
          "docstring": "Abstract base class for generic types.\n\nOn Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::\n\n    class Mapping[KT, VT]:\n        def __getitem__(self, key: KT) -> VT:\n            ...\n        # Etc.\n\nOn older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.\n\nAfter a class has been declared to be generic, it can then be used as\nfollows::\n\n    def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n        try:\n            return mapping[key]\n        except KeyError:\n            return default",
          "module": "livekit.agents.worker",
          "bases": [
            "EventEmitter"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WorkerOptions": {
          "name": "WorkerOptions",
          "docstring": "WorkerOptions(entrypoint_fnc: 'Callable[[JobContext], Awaitable[None]]', request_fnc: 'Callable[[JobRequest], Awaitable[None]]' = <function _default_request_fnc at 0x00000192A7AB1E40>, prewarm_fnc: 'Callable[[JobProcess], Any]' = <function _default_initialize_process_fnc at 0x00000192A7834220>, load_fnc: 'Callable[[Worker], float] | Callable[[], float]' = <bound method _DefaultLoadCalc.get_load of <class 'livekit.agents.worker._DefaultLoadCalc'>>, job_executor_type: 'JobExecutorType' = <JobExecutorType.THREAD: 'thread'>, load_threshold: 'float | _WorkerEnvOption[float]' = _WorkerEnvOption(dev_default=inf, prod_default=0.75), job_memory_warn_mb: 'float' = 500, job_memory_limit_mb: 'float' = 0, drain_timeout: 'int' = 1800, num_idle_processes: 'int | _WorkerEnvOption[int]' = _WorkerEnvOption(dev_default=0, prod_default=22), shutdown_process_timeout: 'float' = 60.0, initialize_process_timeout: 'float' = 10.0, permissions: 'WorkerPermissions' = <factory>, agent_name: 'str' = '', worker_type: 'WorkerType' = <WorkerType.ROOM: 0>, max_retry: 'int' = 16, ws_url: 'str' = 'ws://localhost:7880', api_key: 'str | None' = None, api_secret: 'str | None' = None, _worker_token: 'str | None' = None, host: 'str' = '', port: 'int | _WorkerEnvOption[int]' = _WorkerEnvOption(dev_default=0, prod_default=8081), http_proxy: 'NotGivenOr[str | None]' = NOT_GIVEN, multiprocessing_context: \"Literal['spawn', 'forkserver']\" = 'spawn')",
          "module": "livekit.agents.worker",
          "bases": [
            "object"
          ],
          "methods": {
            "load_fnc": {
              "name": "get_load",
              "docstring": "No documentation available",
              "signature": "(worker: 'Worker') -> 'float'",
              "parameters": [
                {
                  "name": "worker",
                  "annotation": "Worker",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "float",
              "module": "livekit.agents.worker"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WorkerPermissions": {
          "name": "WorkerPermissions",
          "docstring": "WorkerPermissions(can_publish: 'bool' = True, can_subscribe: 'bool' = True, can_publish_data: 'bool' = True, can_update_metadata: 'bool' = True, can_publish_sources: 'list[models.TrackSource]' = <factory>, hidden: 'bool' = False)",
          "module": "livekit.agents.worker",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WorkerType": {
          "name": "WorkerType",
          "docstring": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
          "module": "livekit.agents.worker",
          "bases": [
            "Enum"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        }
      },
      "functions": {
        "function_tool": {
          "name": "function_tool",
          "docstring": "No documentation available",
          "signature": "(f: 'F | Raw_F | None' = None, *, name: 'str | None' = None, description: 'str | None' = None, raw_schema: 'RawFunctionDescription | dict[str, Any] | None' = None) -> 'FunctionTool | RawFunctionTool | Callable[[F], FunctionTool] | Callable[[Raw_F], RawFunctionTool]'",
          "parameters": [
            {
              "name": "f",
              "annotation": "F | Raw_F | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "name",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "description",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raw_schema",
              "annotation": "RawFunctionDescription | dict[str, Any] | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "FunctionTool | RawFunctionTool | Callable[[F], FunctionTool] | Callable[[Raw_F], RawFunctionTool]",
          "module": "livekit.agents.llm.tool_context"
        },
        "get_job_context": {
          "name": "get_job_context",
          "docstring": "No documentation available",
          "signature": "() -> 'JobContext'",
          "parameters": [],
          "return_annotation": "JobContext",
          "module": "livekit.agents.job"
        }
      },
      "constants": {
        "DEFAULT_API_CONNECT_OPTIONS": "APIConnectOptions(max_retry=3, retry_interval=2.0, timeout=10.0)",
        "NOT_GIVEN": "NOT_GIVEN",
        "NOT_IN_ALL": "['__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__getattr__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '_exceptions', 'debug', 'http_server', 'inference_runner', 'job', 'log', 'plugin', 'types', 'typing', 'version', 'worker']",
        "n": "worker"
      },
      "submodules": [
        "livekit.agents.voice.avatar",
        "livekit.agents.cli",
        "livekit.agents.debug",
        "livekit.agents.http_server",
        "livekit.agents.inference_runner",
        "livekit.agents.voice.io",
        "livekit.agents.ipc",
        "livekit.agents.job",
        "livekit.agents.llm",
        "livekit.agents.log",
        "livekit.agents.metrics",
        "livekit.agents.plugin",
        "livekit.agents.stt",
        "livekit.agents.tokenize",
        "livekit.agents.tts",
        "livekit.agents.types",
        "livekit.agents.utils",
        "livekit.agents.vad",
        "livekit.agents.version",
        "livekit.agents.voice",
        "livekit.agents.worker"
      ]
    },
    "livekit.agents.llm": {
      "name": "livekit.agents.llm",
      "docstring": "No documentation available",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\agents\\llm\\__init__.py",
      "classes": {
        "AudioContent": {
          "name": "AudioContent",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AvailabilityChangedEvent": {
          "name": "AvailabilityChangedEvent",
          "docstring": "AvailabilityChangedEvent(llm: 'LLM', available: 'bool')",
          "module": "livekit.agents.llm.fallback_adapter",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ChatChunk": {
          "name": "ChatChunk",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.llm",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ChatContext": {
          "name": "ChatContext",
          "docstring": "No documentation available",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "object"
          ],
          "methods": {
            "empty": {
              "name": "empty",
              "docstring": "No documentation available",
              "signature": "() -> 'ChatContext'",
              "parameters": [],
              "return_annotation": "ChatContext",
              "module": "livekit.agents.llm.chat_context"
            },
            "from_dict": {
              "name": "from_dict",
              "docstring": "No documentation available",
              "signature": "(data: 'dict[str, Any]') -> 'ChatContext'",
              "parameters": [
                {
                  "name": "data",
                  "annotation": "dict[str, Any]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "ChatContext",
              "module": "livekit.agents.llm.chat_context"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ChatMessage": {
          "name": "ChatMessage",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ChoiceDelta": {
          "name": "ChoiceDelta",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.llm",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CompletionUsage": {
          "name": "CompletionUsage",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.llm",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FallbackAdapter": {
          "name": "FallbackAdapter",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.llm.fallback_adapter",
          "bases": [
            "LLM"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FunctionCall": {
          "name": "FunctionCall",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FunctionCallOutput": {
          "name": "FunctionCallOutput",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FunctionTool": {
          "name": "FunctionTool",
          "docstring": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto[T](Protocol):\n        def meth(self) -> T:\n            ...",
          "module": "livekit.agents.llm.tool_context",
          "bases": [
            "Protocol"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FunctionToolCall": {
          "name": "FunctionToolCall",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.llm",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "GenerationCreatedEvent": {
          "name": "GenerationCreatedEvent",
          "docstring": "GenerationCreatedEvent(message_stream: 'AsyncIterable[MessageGeneration]', function_stream: 'AsyncIterable[FunctionCall]', user_initiated: 'bool')",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ImageContent": {
          "name": "ImageContent",
          "docstring": "ImageContent is used to input images into the ChatContext on supported LLM providers / plugins.\n\nYou may need to consult your LLM provider's documentation on supported URL types.\n\n```python\n# Pass a VideoFrame directly, which will be automatically converted to a JPEG data URL internally\nasync for event in rtc.VideoStream(video_track):\n    chat_image = ImageContent(image=event.frame)\n    # this instance is now available for your ChatContext\n\n# Encode your VideoFrame yourself for more control, and pass the result as a data URL (see EncodeOptions for more details)\nfrom livekit.agents.utils.images import encode, EncodeOptions, ResizeOptions\n\nimage_bytes = encode(\n    event.frame,\n    EncodeOptions(\n        format=\"PNG\",\n        resize_options=ResizeOptions(width=512, height=512, strategy=\"scale_aspect_fit\"),\n    ),\n)\nchat_image = ImageContent(\n    image=f\"data:image/png;base64,{base64.b64encode(image_bytes).decode('utf-8')}\"\n)\n\n# With an external URL\nchat_image = ImageContent(image=\"https://example.com/image.jpg\")\n```",
          "module": "livekit.agents.llm.chat_context",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "InputSpeechStartedEvent": {
          "name": "InputSpeechStartedEvent",
          "docstring": "InputSpeechStartedEvent()",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "InputSpeechStoppedEvent": {
          "name": "InputSpeechStoppedEvent",
          "docstring": "InputSpeechStoppedEvent(user_transcription_enabled: 'bool')",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "InputTranscriptionCompleted": {
          "name": "InputTranscriptionCompleted",
          "docstring": "InputTranscriptionCompleted(item_id: 'str', transcript: 'str', is_final: 'bool')",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "LLM": {
          "name": "LLM",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.llm.llm",
          "bases": [
            "ABC",
            "EventEmitter",
            "Generic"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "LLMError": {
          "name": "LLMError",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.llm",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "LLMStream": {
          "name": "LLMStream",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.llm.llm",
          "bases": [
            "ABC"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "MessageGeneration": {
          "name": "MessageGeneration",
          "docstring": "MessageGeneration(message_id: 'str', text_stream: 'AsyncIterable[str]', audio_stream: 'AsyncIterable[rtc.AudioFrame]')",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RawFunctionTool": {
          "name": "RawFunctionTool",
          "docstring": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto[T](Protocol):\n        def meth(self) -> T:\n            ...",
          "module": "livekit.agents.llm.tool_context",
          "bases": [
            "Protocol"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RealtimeCapabilities": {
          "name": "RealtimeCapabilities",
          "docstring": "RealtimeCapabilities(message_truncation: 'bool', turn_detection: 'bool', user_transcription: 'bool', auto_tool_reply_generation: 'bool')",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RealtimeError": {
          "name": "RealtimeError",
          "docstring": "Common base class for all non-exit exceptions.",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "Exception"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RealtimeModel": {
          "name": "RealtimeModel",
          "docstring": "No documentation available",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RealtimeModelError": {
          "name": "RealtimeModelError",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RealtimeSession": {
          "name": "RealtimeSession",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "ABC",
            "EventEmitter",
            "Generic"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RealtimeSessionReconnectedEvent": {
          "name": "RealtimeSessionReconnectedEvent",
          "docstring": "RealtimeSessionReconnectedEvent()",
          "module": "livekit.agents.llm.realtime",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StopResponse": {
          "name": "StopResponse",
          "docstring": "Common base class for all non-exit exceptions.",
          "module": "livekit.agents.llm.tool_context",
          "bases": [
            "Exception"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ToolContext": {
          "name": "ToolContext",
          "docstring": "Stateless container for a set of AI functions",
          "module": "livekit.agents.llm.tool_context",
          "bases": [
            "object"
          ],
          "methods": {
            "empty": {
              "name": "empty",
              "docstring": "No documentation available",
              "signature": "() -> 'ToolContext'",
              "parameters": [],
              "return_annotation": "ToolContext",
              "module": "livekit.agents.llm.tool_context"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ToolError": {
          "name": "ToolError",
          "docstring": "Common base class for all non-exit exceptions.",
          "module": "livekit.agents.llm.tool_context",
          "bases": [
            "Exception"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        }
      },
      "functions": {
        "find_function_tools": {
          "name": "find_function_tools",
          "docstring": "No documentation available",
          "signature": "(cls_or_obj: 'Any') -> 'list[FunctionTool | RawFunctionTool]'",
          "parameters": [
            {
              "name": "cls_or_obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "list[FunctionTool | RawFunctionTool]",
          "module": "livekit.agents.llm.tool_context"
        },
        "function_tool": {
          "name": "function_tool",
          "docstring": "No documentation available",
          "signature": "(f: 'F | Raw_F | None' = None, *, name: 'str | None' = None, description: 'str | None' = None, raw_schema: 'RawFunctionDescription | dict[str, Any] | None' = None) -> 'FunctionTool | RawFunctionTool | Callable[[F], FunctionTool] | Callable[[Raw_F], RawFunctionTool]'",
          "parameters": [
            {
              "name": "f",
              "annotation": "F | Raw_F | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "name",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "description",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raw_schema",
              "annotation": "RawFunctionDescription | dict[str, Any] | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "FunctionTool | RawFunctionTool | Callable[[F], FunctionTool] | Callable[[Raw_F], RawFunctionTool]",
          "module": "livekit.agents.llm.tool_context"
        },
        "is_function_tool": {
          "name": "is_function_tool",
          "docstring": "No documentation available",
          "signature": "(f: 'Callable[..., Any]') -> 'TypeGuard[FunctionTool]'",
          "parameters": [
            {
              "name": "f",
              "annotation": "Callable[..., Any]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "TypeGuard[FunctionTool]",
          "module": "livekit.agents.llm.tool_context"
        },
        "is_raw_function_tool": {
          "name": "is_raw_function_tool",
          "docstring": "No documentation available",
          "signature": "(f: 'Callable[..., Any]') -> 'TypeGuard[RawFunctionTool]'",
          "parameters": [
            {
              "name": "f",
              "annotation": "Callable[..., Any]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "TypeGuard[RawFunctionTool]",
          "module": "livekit.agents.llm.tool_context"
        }
      },
      "constants": {
        "NOT_IN_ALL": "['__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '_provider_format', '_strict', 'chat_context', 'fallback_adapter', 'llm', 'realtime', 'tool_context']",
        "n": "tool_context"
      },
      "submodules": [
        "livekit.agents.llm.chat_context",
        "livekit.agents.llm.fallback_adapter",
        "livekit.agents.llm.llm",
        "livekit.agents.llm.realtime",
        "livekit.agents.llm.remote_chat_context",
        "livekit.agents.llm.tool_context",
        "livekit.agents.llm.utils"
      ]
    },
    "livekit.agents.stt": {
      "name": "livekit.agents.stt",
      "docstring": "No documentation available",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\agents\\stt\\__init__.py",
      "classes": {
        "AvailabilityChangedEvent": {
          "name": "AvailabilityChangedEvent",
          "docstring": "AvailabilityChangedEvent(stt: 'STT', available: 'bool')",
          "module": "livekit.agents.stt.fallback_adapter",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FallbackAdapter": {
          "name": "FallbackAdapter",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.stt.fallback_adapter",
          "bases": [
            "STT"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RecognitionUsage": {
          "name": "RecognitionUsage",
          "docstring": "RecognitionUsage(audio_duration: 'float')",
          "module": "livekit.agents.stt.stt",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RecognizeStream": {
          "name": "RecognizeStream",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.stt.stt",
          "bases": [
            "ABC"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "STT": {
          "name": "STT",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.stt.stt",
          "bases": [
            "ABC",
            "EventEmitter",
            "Generic"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "STTCapabilities": {
          "name": "STTCapabilities",
          "docstring": "STTCapabilities(streaming: 'bool', interim_results: 'bool')",
          "module": "livekit.agents.stt.stt",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "STTError": {
          "name": "STTError",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.stt.stt",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SpeechData": {
          "name": "SpeechData",
          "docstring": "SpeechData(language: 'str', text: 'str', start_time: 'float' = 0.0, end_time: 'float' = 0.0, confidence: 'float' = 0.0, speaker_id: 'str | None' = None)",
          "module": "livekit.agents.stt.stt",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SpeechEvent": {
          "name": "SpeechEvent",
          "docstring": "SpeechEvent(type: 'SpeechEventType', request_id: 'str' = '', alternatives: 'list[SpeechData]' = <factory>, recognition_usage: 'RecognitionUsage | None' = None)",
          "module": "livekit.agents.stt.stt",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SpeechEventType": {
          "name": "SpeechEventType",
          "docstring": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to 'utf-8'.\nerrors defaults to 'strict'.",
          "module": "livekit.agents.stt.stt",
          "bases": [
            "str",
            "Enum"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SpeechStream": {
          "name": "RecognizeStream",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.stt.stt",
          "bases": [
            "ABC"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StreamAdapter": {
          "name": "StreamAdapter",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.stt.stream_adapter",
          "bases": [
            "STT"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StreamAdapterWrapper": {
          "name": "StreamAdapterWrapper",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.stt.stream_adapter",
          "bases": [
            "RecognizeStream"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        }
      },
      "functions": {},
      "constants": {
        "NOT_IN_ALL": "['__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'fallback_adapter', 'stream_adapter', 'stt']",
        "n": "stt"
      },
      "submodules": [
        "livekit.agents.stt.fallback_adapter",
        "livekit.agents.stt.stream_adapter",
        "livekit.agents.stt.stt"
      ]
    },
    "livekit.agents.tts": {
      "name": "livekit.agents.tts",
      "docstring": "No documentation available",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\agents\\tts\\__init__.py",
      "classes": {
        "AudioEmitter": {
          "name": "AudioEmitter",
          "docstring": "No documentation available",
          "module": "livekit.agents.tts.tts",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AvailabilityChangedEvent": {
          "name": "AvailabilityChangedEvent",
          "docstring": "AvailabilityChangedEvent(tts: 'TTS', available: 'bool')",
          "module": "livekit.agents.tts.fallback_adapter",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ChunkedStream": {
          "name": "ChunkedStream",
          "docstring": "Used by the non-streamed synthesize API, some providers support chunked http responses",
          "module": "livekit.agents.tts.tts",
          "bases": [
            "ABC"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FallbackAdapter": {
          "name": "FallbackAdapter",
          "docstring": "Manages multiple TTS instances, providing a fallback mechanism to ensure continuous TTS service.",
          "module": "livekit.agents.tts.fallback_adapter",
          "bases": [
            "TTS"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FallbackChunkedStream": {
          "name": "FallbackChunkedStream",
          "docstring": "Used by the non-streamed synthesize API, some providers support chunked http responses",
          "module": "livekit.agents.tts.fallback_adapter",
          "bases": [
            "ChunkedStream"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FallbackSynthesizeStream": {
          "name": "FallbackSynthesizeStream",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.tts.fallback_adapter",
          "bases": [
            "SynthesizeStream"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StreamAdapter": {
          "name": "StreamAdapter",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.tts.stream_adapter",
          "bases": [
            "TTS"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StreamAdapterWrapper": {
          "name": "StreamAdapterWrapper",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.tts.stream_adapter",
          "bases": [
            "SynthesizeStream"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SynthesizeStream": {
          "name": "SynthesizeStream",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.tts.tts",
          "bases": [
            "ABC"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SynthesizedAudio": {
          "name": "SynthesizedAudio",
          "docstring": "SynthesizedAudio(frame: 'rtc.AudioFrame', request_id: 'str', is_final: 'bool' = False, segment_id: 'str' = '', delta_text: 'str' = '')",
          "module": "livekit.agents.tts.tts",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TTS": {
          "name": "TTS",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.tts.tts",
          "bases": [
            "ABC",
            "EventEmitter",
            "Generic"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TTSCapabilities": {
          "name": "TTSCapabilities",
          "docstring": "TTSCapabilities(streaming: 'bool')",
          "module": "livekit.agents.tts.tts",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TTSError": {
          "name": "TTSError",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "module": "livekit.agents.tts.tts",
          "bases": [
            "BaseModel"
          ],
          "methods": {
            "construct": {
              "name": "construct",
              "docstring": "No documentation available",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "from_orm": {
              "name": "from_orm",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_construct": {
              "name": "model_construct",
              "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "_fields_set",
                  "annotation": "set[str] | None",
                  "default": "None",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "values",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_json_schema": {
              "name": "model_json_schema",
              "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "schema_generator",
                  "annotation": "type[GenerateJsonSchema]",
                  "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "mode",
                  "annotation": "JsonSchemaMode",
                  "default": "validation",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "dict[str, Any]",
              "module": "pydantic.main"
            },
            "model_parametrized_name": {
              "name": "model_parametrized_name",
              "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "parameters": [
                {
                  "name": "params",
                  "annotation": "tuple[type[Any], ...]",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "model_rebuild": {
              "name": "model_rebuild",
              "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "parameters": [
                {
                  "name": "force",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "raise_errors",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_parent_namespace_depth",
                  "annotation": "int",
                  "default": "2",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "_types_namespace",
                  "annotation": "MappingNamespace | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "bool | None",
              "module": "pydantic.main"
            },
            "model_validate": {
              "name": "model_validate",
              "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "from_attributes",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_json": {
              "name": "model_validate_json",
              "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "json_data",
                  "annotation": "str | bytes | bytearray",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "model_validate_strings": {
              "name": "model_validate_strings",
              "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "strict",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "context",
                  "annotation": "Any | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_alias",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "by_name",
                  "annotation": "bool | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_file": {
              "name": "parse_file",
              "docstring": "No documentation available",
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "path",
                  "annotation": "str | Path",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_obj": {
              "name": "parse_obj",
              "docstring": "No documentation available",
              "signature": "(obj: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "obj",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "parse_raw": {
              "name": "parse_raw",
              "docstring": "No documentation available",
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "parameters": [
                {
                  "name": "b",
                  "annotation": "str | bytes",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "content_type",
                  "annotation": "str | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "encoding",
                  "annotation": "str",
                  "default": "utf8",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "proto",
                  "annotation": "DeprecatedParseProtocol | None",
                  "default": "None",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "allow_pickle",
                  "annotation": "bool",
                  "default": "False",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            },
            "schema": {
              "name": "schema",
              "docstring": "No documentation available",
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "POSITIONAL_OR_KEYWORD"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Dict[str, Any]",
              "module": "pydantic.main"
            },
            "schema_json": {
              "name": "schema_json",
              "docstring": "No documentation available",
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "parameters": [
                {
                  "name": "by_alias",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "ref_template",
                  "annotation": "str",
                  "default": "#/$defs/{model}",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "dumps_kwargs",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "str",
              "module": "pydantic.main"
            },
            "update_forward_refs": {
              "name": "update_forward_refs",
              "docstring": "No documentation available",
              "signature": "(**localns: 'Any') -> 'None'",
              "parameters": [
                {
                  "name": "localns",
                  "annotation": "Any",
                  "default": null,
                  "kind": "VAR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "pydantic.main"
            },
            "validate": {
              "name": "validate",
              "docstring": "No documentation available",
              "signature": "(value: 'Any') -> 'Self'",
              "parameters": [
                {
                  "name": "value",
                  "annotation": "Any",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "Self",
              "module": "pydantic.main"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        }
      },
      "functions": {},
      "constants": {
        "NOT_IN_ALL": "['__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'fallback_adapter', 'stream_adapter', 'tts']",
        "n": "tts"
      },
      "submodules": [
        "livekit.agents.tts.fallback_adapter",
        "livekit.agents.tts.stream_adapter",
        "livekit.agents.tts.tts"
      ]
    },
    "livekit.api": {
      "name": "livekit.api",
      "docstring": "LiveKit Server APIs for Python\n\n`pip install livekit-api`\n\nManage rooms, participants, egress, ingress, SIP, and Agent dispatch.\n\nPrimary entry point is `LiveKitAPI`.\n\nSee https://docs.livekit.io/reference/server/server-apis for more information.",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\api\\__init__.py",
      "classes": {
        "AccessToken": {
          "name": "AccessToken",
          "docstring": "No documentation available",
          "module": "livekit.api.access_token",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ActiveSpeakerUpdate": {
          "name": "ActiveSpeakerUpdate",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AgentDispatch": {
          "name": "AgentDispatch",
          "docstring": "A ProtocolMessage",
          "module": "agent_dispatch",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AgentDispatchState": {
          "name": "AgentDispatchState",
          "docstring": "A ProtocolMessage",
          "module": "agent_dispatch",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AliOSSUpload": {
          "name": "AliOSSUpload",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AutoParticipantEgress": {
          "name": "AutoParticipantEgress",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AutoTrackEgress": {
          "name": "AutoTrackEgress",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AvailabilityRequest": {
          "name": "AvailabilityRequest",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AvailabilityResponse": {
          "name": "AvailabilityResponse",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "AzureBlobUpload": {
          "name": "AzureBlobUpload",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ChatMessage": {
          "name": "ChatMessage",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ClientConfiguration": {
          "name": "ClientConfiguration",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ClientInfo": {
          "name": "ClientInfo",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Codec": {
          "name": "Codec",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CreateAgentDispatchRequest": {
          "name": "CreateAgentDispatchRequest",
          "docstring": "A ProtocolMessage",
          "module": "agent_dispatch",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CreateIngressRequest": {
          "name": "CreateIngressRequest",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CreateRoomRequest": {
          "name": "CreateRoomRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CreateSIPDispatchRuleRequest": {
          "name": "CreateSIPDispatchRuleRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CreateSIPInboundTrunkRequest": {
          "name": "CreateSIPInboundTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CreateSIPOutboundTrunkRequest": {
          "name": "CreateSIPOutboundTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CreateSIPParticipantRequest": {
          "name": "CreateSIPParticipantRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "CreateSIPTrunkRequest": {
          "name": "CreateSIPTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DataPacket": {
          "name": "DataPacket",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DataStream": {
          "name": "DataStream",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DeleteAgentDispatchRequest": {
          "name": "DeleteAgentDispatchRequest",
          "docstring": "A ProtocolMessage",
          "module": "agent_dispatch",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DeleteIngressRequest": {
          "name": "DeleteIngressRequest",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DeleteRoomRequest": {
          "name": "DeleteRoomRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DeleteRoomResponse": {
          "name": "DeleteRoomResponse",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DeleteSIPDispatchRuleRequest": {
          "name": "DeleteSIPDispatchRuleRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DeleteSIPTrunkRequest": {
          "name": "DeleteSIPTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DirectFileOutput": {
          "name": "DirectFileOutput",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DisabledCodecs": {
          "name": "DisabledCodecs",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "EgressInfo": {
          "name": "EgressInfo",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "EncodedFileOutput": {
          "name": "EncodedFileOutput",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "EncodingOptions": {
          "name": "EncodingOptions",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Encryption": {
          "name": "Encryption",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "FileInfo": {
          "name": "FileInfo",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ForwardParticipantRequest": {
          "name": "ForwardParticipantRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ForwardParticipantResponse": {
          "name": "ForwardParticipantResponse",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "GCPUpload": {
          "name": "GCPUpload",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "GetSIPInboundTrunkRequest": {
          "name": "GetSIPInboundTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "GetSIPInboundTrunkResponse": {
          "name": "GetSIPInboundTrunkResponse",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "GetSIPOutboundTrunkRequest": {
          "name": "GetSIPOutboundTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "GetSIPOutboundTrunkResponse": {
          "name": "GetSIPOutboundTrunkResponse",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ImageOutput": {
          "name": "ImageOutput",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ImagesInfo": {
          "name": "ImagesInfo",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "IngressAudioEncodingOptions": {
          "name": "IngressAudioEncodingOptions",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "IngressAudioOptions": {
          "name": "IngressAudioOptions",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "IngressInfo": {
          "name": "IngressInfo",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "IngressState": {
          "name": "IngressState",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "IngressVideoEncodingOptions": {
          "name": "IngressVideoEncodingOptions",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "IngressVideoOptions": {
          "name": "IngressVideoOptions",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "InputAudioState": {
          "name": "InputAudioState",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "InputVideoState": {
          "name": "InputVideoState",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Job": {
          "name": "Job",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "JobAssignment": {
          "name": "JobAssignment",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "JobState": {
          "name": "JobState",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "JobTermination": {
          "name": "JobTermination",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListAgentDispatchRequest": {
          "name": "ListAgentDispatchRequest",
          "docstring": "A ProtocolMessage",
          "module": "agent_dispatch",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListAgentDispatchResponse": {
          "name": "ListAgentDispatchResponse",
          "docstring": "A ProtocolMessage",
          "module": "agent_dispatch",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListEgressRequest": {
          "name": "ListEgressRequest",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListEgressResponse": {
          "name": "ListEgressResponse",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListIngressRequest": {
          "name": "ListIngressRequest",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListIngressResponse": {
          "name": "ListIngressResponse",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListParticipantsRequest": {
          "name": "ListParticipantsRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListParticipantsResponse": {
          "name": "ListParticipantsResponse",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListRoomsRequest": {
          "name": "ListRoomsRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListRoomsResponse": {
          "name": "ListRoomsResponse",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListSIPDispatchRuleRequest": {
          "name": "ListSIPDispatchRuleRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListSIPDispatchRuleResponse": {
          "name": "ListSIPDispatchRuleResponse",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListSIPInboundTrunkRequest": {
          "name": "ListSIPInboundTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListSIPInboundTrunkResponse": {
          "name": "ListSIPInboundTrunkResponse",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListSIPOutboundTrunkRequest": {
          "name": "ListSIPOutboundTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListSIPOutboundTrunkResponse": {
          "name": "ListSIPOutboundTrunkResponse",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListSIPTrunkRequest": {
          "name": "ListSIPTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListSIPTrunkResponse": {
          "name": "ListSIPTrunkResponse",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ListUpdate": {
          "name": "ListUpdate",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "LiveKitAPI": {
          "name": "LiveKitAPI",
          "docstring": "LiveKit Server API Client\n\nThis class is the main entrypoint, which exposes all services.\n\nUsage:\n\n```python\nfrom livekit import api\nlkapi = api.LiveKitAPI()\nrooms = await lkapi.room.list_rooms(api.proto_room.ListRoomsRequest(names=['test-room']))\n```",
          "module": "livekit.api.livekit_api",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "MigrateJobRequest": {
          "name": "MigrateJobRequest",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "MoveParticipantRequest": {
          "name": "MoveParticipantRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "MoveParticipantResponse": {
          "name": "MoveParticipantResponse",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "MuteRoomTrackRequest": {
          "name": "MuteRoomTrackRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "MuteRoomTrackResponse": {
          "name": "MuteRoomTrackResponse",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Pagination": {
          "name": "Pagination",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ParticipantEgressRequest": {
          "name": "ParticipantEgressRequest",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ParticipantInfo": {
          "name": "ParticipantInfo",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ParticipantPermission": {
          "name": "ParticipantPermission",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ParticipantTracks": {
          "name": "ParticipantTracks",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "PlayoutDelay": {
          "name": "PlayoutDelay",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ProxyConfig": {
          "name": "ProxyConfig",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RTCPSenderReportState": {
          "name": "RTCPSenderReportState",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RTPDrift": {
          "name": "RTPDrift",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RTPForwarderState": {
          "name": "RTPForwarderState",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RTPMungerState": {
          "name": "RTPMungerState",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RTPStats": {
          "name": "RTPStats",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RegisterWorkerRequest": {
          "name": "RegisterWorkerRequest",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RegisterWorkerResponse": {
          "name": "RegisterWorkerResponse",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RemoveParticipantResponse": {
          "name": "RemoveParticipantResponse",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Room": {
          "name": "Room",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RoomAgent": {
          "name": "RoomAgent",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RoomAgentDispatch": {
          "name": "RoomAgentDispatch",
          "docstring": "A ProtocolMessage",
          "module": "agent_dispatch",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RoomCompositeEgressRequest": {
          "name": "RoomCompositeEgressRequest",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RoomConfiguration": {
          "name": "RoomConfiguration",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RoomEgress": {
          "name": "RoomEgress",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RoomParticipantIdentity": {
          "name": "RoomParticipantIdentity",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RpcAck": {
          "name": "RpcAck",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RpcError": {
          "name": "RpcError",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RpcRequest": {
          "name": "RpcRequest",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "RpcResponse": {
          "name": "RpcResponse",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "S3Upload": {
          "name": "S3Upload",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPCallInfo": {
          "name": "SIPCallInfo",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPDispatchRule": {
          "name": "SIPDispatchRule",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPDispatchRuleCallee": {
          "name": "SIPDispatchRuleCallee",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPDispatchRuleDirect": {
          "name": "SIPDispatchRuleDirect",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPDispatchRuleIndividual": {
          "name": "SIPDispatchRuleIndividual",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPDispatchRuleInfo": {
          "name": "SIPDispatchRuleInfo",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPDispatchRuleUpdate": {
          "name": "SIPDispatchRuleUpdate",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPGrants": {
          "name": "SIPGrants",
          "docstring": "SIPGrants(admin: bool = False, call: bool = False)",
          "module": "livekit.api.access_token",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPInboundTrunkInfo": {
          "name": "SIPInboundTrunkInfo",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPInboundTrunkUpdate": {
          "name": "SIPInboundTrunkUpdate",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPOutboundConfig": {
          "name": "SIPOutboundConfig",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPOutboundTrunkInfo": {
          "name": "SIPOutboundTrunkInfo",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPOutboundTrunkUpdate": {
          "name": "SIPOutboundTrunkUpdate",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPParticipantInfo": {
          "name": "SIPParticipantInfo",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPStatus": {
          "name": "SIPStatus",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPTransferInfo": {
          "name": "SIPTransferInfo",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPTrunkInfo": {
          "name": "SIPTrunkInfo",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SIPUri": {
          "name": "SIPUri",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SegmentedFileOutput": {
          "name": "SegmentedFileOutput",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SegmentsInfo": {
          "name": "SegmentsInfo",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SendDataRequest": {
          "name": "SendDataRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SendDataResponse": {
          "name": "SendDataResponse",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ServerInfo": {
          "name": "ServerInfo",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ServerMessage": {
          "name": "ServerMessage",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SimulateJobRequest": {
          "name": "SimulateJobRequest",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SimulcastCodecInfo": {
          "name": "SimulcastCodecInfo",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SipDTMF": {
          "name": "SipDTMF",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SpeakerInfo": {
          "name": "SpeakerInfo",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StopEgressRequest": {
          "name": "StopEgressRequest",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StreamInfo": {
          "name": "StreamInfo",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StreamInfoList": {
          "name": "StreamInfoList",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "StreamOutput": {
          "name": "StreamOutput",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TimedVersion": {
          "name": "TimedVersion",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TokenVerifier": {
          "name": "TokenVerifier",
          "docstring": "No documentation available",
          "module": "livekit.api.access_token",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TrackCompositeEgressRequest": {
          "name": "TrackCompositeEgressRequest",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TrackEgressRequest": {
          "name": "TrackEgressRequest",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TrackInfo": {
          "name": "TrackInfo",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Transcription": {
          "name": "Transcription",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TranscriptionSegment": {
          "name": "TranscriptionSegment",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TransferSIPParticipantRequest": {
          "name": "TransferSIPParticipantRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TwirpError": {
          "name": "TwirpError",
          "docstring": "Common base class for all non-exit exceptions.",
          "module": "livekit.api.twirp_client",
          "bases": [
            "Exception"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TwirpErrorCode": {
          "name": "TwirpErrorCode",
          "docstring": "No documentation available",
          "module": "livekit.api.twirp_client",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateIngressRequest": {
          "name": "UpdateIngressRequest",
          "docstring": "A ProtocolMessage",
          "module": "ingress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateJobStatus": {
          "name": "UpdateJobStatus",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateLayoutRequest": {
          "name": "UpdateLayoutRequest",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateParticipantRequest": {
          "name": "UpdateParticipantRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateRoomMetadataRequest": {
          "name": "UpdateRoomMetadataRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateSIPDispatchRuleRequest": {
          "name": "UpdateSIPDispatchRuleRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateSIPInboundTrunkRequest": {
          "name": "UpdateSIPInboundTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateSIPOutboundTrunkRequest": {
          "name": "UpdateSIPOutboundTrunkRequest",
          "docstring": "A ProtocolMessage",
          "module": "sip",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateStreamRequest": {
          "name": "UpdateStreamRequest",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateSubscriptionsRequest": {
          "name": "UpdateSubscriptionsRequest",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateSubscriptionsResponse": {
          "name": "UpdateSubscriptionsResponse",
          "docstring": "A ProtocolMessage",
          "module": "room",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UpdateWorkerStatus": {
          "name": "UpdateWorkerStatus",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "UserPacket": {
          "name": "UserPacket",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "VP8MungerState": {
          "name": "VP8MungerState",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "VideoConfiguration": {
          "name": "VideoConfiguration",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "VideoGrants": {
          "name": "VideoGrants",
          "docstring": "VideoGrants(room_create: Optional[bool] = None, room_list: Optional[bool] = None, room_record: Optional[bool] = None, room_admin: Optional[bool] = None, room_join: Optional[bool] = None, room: str = '', can_publish: bool = True, can_subscribe: bool = True, can_publish_data: bool = True, can_publish_sources: Optional[List[str]] = None, can_update_own_metadata: Optional[bool] = None, ingress_admin: Optional[bool] = None, hidden: Optional[bool] = None, recorder: Optional[bool] = None, agent: Optional[bool] = None)",
          "module": "livekit.api.access_token",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "VideoLayer": {
          "name": "VideoLayer",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WebEgressRequest": {
          "name": "WebEgressRequest",
          "docstring": "A ProtocolMessage",
          "module": "egress",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WebhookConfig": {
          "name": "WebhookConfig",
          "docstring": "A ProtocolMessage",
          "module": "models",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WebhookEvent": {
          "name": "WebhookEvent",
          "docstring": "A ProtocolMessage",
          "module": "webhook",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WebhookReceiver": {
          "name": "WebhookReceiver",
          "docstring": "No documentation available",
          "module": "livekit.api.webhook",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WorkerMessage": {
          "name": "WorkerMessage",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WorkerPing": {
          "name": "WorkerPing",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "WorkerPong": {
          "name": "WorkerPong",
          "docstring": "A ProtocolMessage",
          "module": "agent",
          "bases": [
            "Message",
            "Message"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        }
      },
      "functions": {},
      "constants": {
        "AAC": "2",
        "AUDIO": "0",
        "AudioCodec": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A65D0>",
        "AudioMixing": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A75F0>",
        "AudioTrackFeature": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A70B0>",
        "BackupCodecPolicy": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6D50>",
        "CAMERA": "1",
        "CLIENT_INITIATED": "1",
        "CONNECTION_TIMEOUT": "14",
        "ClientConfigSetting": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6F30>",
        "ConnectionQuality": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6ED0>",
        "DATA": "2",
        "DEFAULT_AC": "0",
        "DEFAULT_FILETYPE": "0",
        "DEFAULT_MIXING": "0",
        "DEFAULT_PROTOCOL": "0",
        "DEFAULT_SEGMENTED_FILE_PROTOCOL": "0",
        "DEFAULT_VC": "0",
        "DESCRIPTOR": "<google._upb._message.FileDescriptor object at 0x00000192A79FD670>",
        "DISABLED": "1",
        "DUAL_CHANNEL_AGENT": "1",
        "DUAL_CHANNEL_ALTERNATE": "2",
        "DUPLICATE_IDENTITY": "2",
        "DisconnectReason": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6F90>",
        "EGRESS_ABORTED": "5",
        "EGRESS_ACTIVE": "1",
        "EGRESS_COMPLETE": "3",
        "EGRESS_ENDING": "2",
        "EGRESS_FAILED": "4",
        "EGRESS_LIMIT_REACHED": "6",
        "EGRESS_SOURCE_TYPE_SDK": "1",
        "EGRESS_SOURCE_TYPE_WEB": "0",
        "EGRESS_STARTING": "0",
        "ENABLED": "2",
        "EXCELLENT": "2",
        "EgressSourceType": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7710>",
        "EgressStatus": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A76B0>",
        "EncodedFileType": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7410>",
        "EncodingOptionsPreset": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7650>",
        "GOOD": "1",
        "H264_1080P_30": "2",
        "H264_1080P_30FPS_1_LAYER": "4",
        "H264_1080P_30FPS_1_LAYER_HIGH_MOTION": "9",
        "H264_1080P_30FPS_3_LAYERS": "1",
        "H264_1080P_30FPS_3_LAYERS_HIGH_MOTION": "6",
        "H264_1080P_60": "3",
        "H264_540P_25FPS_2_LAYERS": "2",
        "H264_540P_25FPS_2_LAYERS_HIGH_MOTION": "7",
        "H264_720P_30": "0",
        "H264_720P_30FPS_1_LAYER": "3",
        "H264_720P_30FPS_1_LAYER_HIGH_MOTION": "8",
        "H264_720P_30FPS_3_LAYERS": "0",
        "H264_720P_30FPS_3_LAYERS_HIGH_MOTION": "5",
        "H264_720P_60": "1",
        "H264_BASELINE": "1",
        "H264_HIGH": "3",
        "H264_MAIN": "2",
        "HIGH": "2",
        "HLS_PROTOCOL": "1",
        "IC_DEFAULT": "0",
        "IC_JPEG": "1",
        "IMAGE_SUFFIX_INDEX": "0",
        "IMAGE_SUFFIX_NONE_OVERWRITE": "2",
        "IMAGE_SUFFIX_TIMESTAMP": "1",
        "INDEX": "0",
        "ImageCodec": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6CF0>",
        "ImageFileSuffix": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7530>",
        "IngressAudioEncodingPreset": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7830>",
        "IngressInput": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A77D0>",
        "IngressVideoEncodingPreset": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7890>",
        "JOIN_FAILURE": "7",
        "JS_FAILED": "3",
        "JS_PENDING": "0",
        "JS_RUNNING": "1",
        "JS_SUCCESS": "2",
        "JT_PARTICIPANT": "2",
        "JT_PUBLISHER": "1",
        "JT_ROOM": "0",
        "JobStatus": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A71D0>",
        "JobType": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7110>",
        "KRISP_ENABLED": "1",
        "LOST": "3",
        "LOW": "0",
        "MEDIUM": "1",
        "MICROPHONE": "2",
        "MIGRATION": "8",
        "MP4": "1",
        "NONE": "0",
        "OFF": "3",
        "OGG": "2",
        "OPUS": "1",
        "OPUS_MONO_64KBS": "1",
        "OPUS_STEREO_96KBPS": "0",
        "PARTICIPANT_REMOVED": "4",
        "POOR": "0",
        "PORTRAIT_H264_1080P_30": "6",
        "PORTRAIT_H264_1080P_60": "7",
        "PORTRAIT_H264_720P_30": "4",
        "PORTRAIT_H264_720P_60": "5",
        "PREFER_REGRESSION": "0",
        "REGRESSION": "2",
        "ROOM_CLOSED": "10",
        "ROOM_DELETED": "5",
        "RR_PUBLISHER_FAILED": "2",
        "RR_SIGNAL_DISCONNECTED": "1",
        "RR_SUBSCRIBER_FAILED": "3",
        "RR_SWITCH_CANDIDATE": "4",
        "RR_UNKNOWN": "0",
        "RTMP": "1",
        "RTMP_INPUT": "0",
        "ReconnectReason": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6FF0>",
        "SCD_INBOUND": "1",
        "SCD_OUTBOUND": "2",
        "SCD_UNKNOWN": "0",
        "SCREEN_SHARE": "3",
        "SCREEN_SHARE_AUDIO": "4",
        "SCS_ACTIVE": "2",
        "SCS_CALL_INCOMING": "0",
        "SCS_DISCONNECTED": "3",
        "SCS_ERROR": "4",
        "SCS_PARTICIPANT_JOINED": "1",
        "SERVER_SHUTDOWN": "3",
        "SE_CODEC_UNSUPPORTED": "1",
        "SE_TRACK_NOTFOUND": "2",
        "SE_UNKNOWN": "0",
        "SIGNAL_CLOSE": "9",
        "SIMULCAST": "1",
        "SIPCallDirection": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A7A10710>",
        "SIPCallStatus": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A7A105F0>",
        "SIPFeature": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A7A106B0>",
        "SIPHeaderOptions": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A7A10530>",
        "SIPMediaEncryption": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A7A10590>",
        "SIPStatusCode": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A7A10350>",
        "SIPTransferStatus": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A7A10650>",
        "SIPTransport": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A7A104D0>",
        "SIP_ALL_HEADERS": "2",
        "SIP_MEDIA_ENCRYPT_ALLOW": "1",
        "SIP_MEDIA_ENCRYPT_DISABLE": "0",
        "SIP_MEDIA_ENCRYPT_REQUIRE": "2",
        "SIP_NO_HEADERS": "0",
        "SIP_STATUS_ACCEPTED": "202",
        "SIP_STATUS_ADDRESS_INCOMPLETE": "484",
        "SIP_STATUS_AMBIGUOUS": "485",
        "SIP_STATUS_BAD_EXTENSION": "420",
        "SIP_STATUS_BAD_GATEWAY": "502",
        "SIP_STATUS_BAD_REQUEST": "400",
        "SIP_STATUS_BUSY_HERE": "486",
        "SIP_STATUS_CALL_IS_FORWARDED": "181",
        "SIP_STATUS_CALL_TRANSACTION_DOES_NOT_EXISTS": "481",
        "SIP_STATUS_CONFLICT": "409",
        "SIP_STATUS_EXTENSION_REQUIRED": "421",
        "SIP_STATUS_FORBIDDEN": "403",
        "SIP_STATUS_GATEWAY_TIMEOUT": "504",
        "SIP_STATUS_GLOBAL_BUSY_EVERYWHERE": "600",
        "SIP_STATUS_GLOBAL_DECLINE": "603",
        "SIP_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE": "604",
        "SIP_STATUS_GLOBAL_NOT_ACCEPTABLE": "606",
        "SIP_STATUS_GONE": "410",
        "SIP_STATUS_INTERNAL_SERVER_ERROR": "500",
        "SIP_STATUS_INTERVAL_TOO_BRIEF": "423",
        "SIP_STATUS_LOOP_DETECTED": "482",
        "SIP_STATUS_MESSAGE_TOO_LARGE": "513",
        "SIP_STATUS_METHOD_NOT_ALLOWED": "405",
        "SIP_STATUS_MOVED_PERMANENTLY": "301",
        "SIP_STATUS_MOVED_TEMPORARILY": "302",
        "SIP_STATUS_NOTFOUND": "404",
        "SIP_STATUS_NOT_ACCEPTABLE": "406",
        "SIP_STATUS_NOT_ACCEPTABLE_HERE": "488",
        "SIP_STATUS_NOT_IMPLEMENTED": "501",
        "SIP_STATUS_OK": "200",
        "SIP_STATUS_PAYMENT_REQUIRED": "402",
        "SIP_STATUS_PROXY_AUTH_REQUIRED": "407",
        "SIP_STATUS_QUEUED": "182",
        "SIP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE": "416",
        "SIP_STATUS_REQUEST_ENTITY_TOO_LARGE": "413",
        "SIP_STATUS_REQUEST_TERMINATED": "487",
        "SIP_STATUS_REQUEST_TIMEOUT": "408",
        "SIP_STATUS_REQUEST_URI_TOO_LONG": "414",
        "SIP_STATUS_RINGING": "180",
        "SIP_STATUS_SERVICE_UNAVAILABLE": "503",
        "SIP_STATUS_SESSION_PROGRESS": "183",
        "SIP_STATUS_TEMPORARILY_UNAVAILABLE": "480",
        "SIP_STATUS_TOO_MANY_HOPS": "483",
        "SIP_STATUS_TRYING": "100",
        "SIP_STATUS_UNAUTHORIZED": "401",
        "SIP_STATUS_UNKNOWN": "0",
        "SIP_STATUS_UNSUPPORTED_MEDIA_TYPE": "415",
        "SIP_STATUS_USE_PROXY": "305",
        "SIP_STATUS_VERSION_NOT_SUPPORTED": "505",
        "SIP_TRANSPORT_AUTO": "0",
        "SIP_TRANSPORT_TCP": "2",
        "SIP_TRANSPORT_TLS": "3",
        "SIP_TRANSPORT_UDP": "1",
        "SIP_TRUNK_FAILURE": "13",
        "SIP_X_HEADERS": "1",
        "SRT": "2",
        "STATE_MISMATCH": "6",
        "STS_TRANSFER_FAILED": "1",
        "STS_TRANSFER_ONGOING": "0",
        "STS_TRANSFER_SUCCESSFUL": "2",
        "SegmentedFileProtocol": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7470>",
        "SegmentedFileSuffix": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A74D0>",
        "StreamProtocol": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7590>",
        "SubscriptionError": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7050>",
        "TF_AUTO_GAIN_CONTROL": "2",
        "TF_ECHO_CANCELLATION": "3",
        "TF_ENHANCED_NOISE_CANCELLATION": "5",
        "TF_NOISE_SUPPRESSION": "4",
        "TF_NO_DTX": "1",
        "TF_PRECONNECT_BUFFER": "6",
        "TF_STEREO": "0",
        "TIMESTAMP": "1",
        "TrackSource": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6E10>",
        "TrackType": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6DB0>",
        "UNKNOWN": "0",
        "UNKNOWN_REASON": "0",
        "UNSET": "0",
        "URL_INPUT": "2",
        "USER_REJECTED": "12",
        "USER_UNAVAILABLE": "11",
        "VIDEO": "1",
        "VP8": "4",
        "VideoCodec": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6C90>",
        "VideoQuality": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A6E70>",
        "WHIP_INPUT": "1",
        "WS_AVAILABLE": "0",
        "WS_FULL": "1",
        "WorkerStatus": "<google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x00000192A79A7170>"
      },
      "submodules": [
        "livekit.api.access_token",
        "livekit.api.agent_dispatch_service",
        "livekit.api.egress_service",
        "livekit.api.ingress_service",
        "livekit.api.livekit_api",
        "livekit.api.room_service",
        "livekit.api.sip_service",
        "livekit.api.twirp_client",
        "livekit.api.version",
        "livekit.api.webhook"
      ]
    },
    "livekit.plugins": {
      "name": "livekit.plugins",
      "docstring": "No documentation available",
      "file": null,
      "classes": {},
      "functions": {},
      "constants": {},
      "submodules": [
        "livekit.plugins.cartesia",
        "livekit.plugins.deepgram",
        "livekit.plugins.openai",
        "livekit.plugins.silero"
      ]
    },
    "livekit.plugins.cartesia": {
      "name": "livekit.plugins.cartesia",
      "docstring": "Cartesia plugin for LiveKit Agents\n\nSee https://docs.livekit.io/agents/integrations/tts/cartesia/ for more information.",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\plugins\\cartesia\\__init__.py",
      "classes": {
        "CartesiaPlugin": {
          "name": "CartesiaPlugin",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.cartesia",
          "bases": [
            "Plugin"
          ],
          "methods": {
            "register_plugin": {
              "name": "register_plugin",
              "docstring": "No documentation available",
              "signature": "(plugin: 'Plugin') -> 'None'",
              "parameters": [
                {
                  "name": "plugin",
                  "annotation": "Plugin",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "livekit.agents.plugin"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "ChunkedStream": {
          "name": "ChunkedStream",
          "docstring": "Synthesize chunked text using the bytes endpoint",
          "module": "livekit.plugins.cartesia.tts",
          "bases": [
            "ChunkedStream"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Plugin": {
          "name": "Plugin",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.plugin",
          "bases": [
            "ABC"
          ],
          "methods": {
            "register_plugin": {
              "name": "register_plugin",
              "docstring": "No documentation available",
              "signature": "(plugin: 'Plugin') -> 'None'",
              "parameters": [
                {
                  "name": "plugin",
                  "annotation": "Plugin",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "livekit.agents.plugin"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "STT": {
          "name": "STT",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.cartesia.stt",
          "bases": [
            "STT"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TTS": {
          "name": "TTS",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.cartesia.tts",
          "bases": [
            "TTS"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        }
      },
      "functions": {},
      "constants": {
        "NOT_IN_ALL": "['CartesiaPlugin', 'Plugin', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'log', 'logger', 'models', 'stt', 'tts', 'version']",
        "logger": "<Logger livekit.plugins.cartesia (WARNING)>",
        "n": "version"
      },
      "submodules": [
        "livekit.plugins.cartesia.log",
        "livekit.plugins.cartesia.models",
        "livekit.plugins.cartesia.stt",
        "livekit.plugins.cartesia.tts",
        "livekit.plugins.cartesia.version"
      ]
    },
    "livekit.plugins.deepgram": {
      "name": "livekit.plugins.deepgram",
      "docstring": "Deepgram plugin for LiveKit Agents\n\nSupport for speech-to-text with [Deepgram](https://deepgram.com/).\n\nSee https://docs.livekit.io/agents/integrations/stt/deepgram/ for more information.",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\plugins\\deepgram\\__init__.py",
      "classes": {
        "AudioEnergyFilter": {
          "name": "AudioEnergyFilter",
          "docstring": "No documentation available",
          "module": "livekit.plugins.deepgram.stt",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "DeepgramPlugin": {
          "name": "DeepgramPlugin",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.deepgram",
          "bases": [
            "Plugin"
          ],
          "methods": {
            "register_plugin": {
              "name": "register_plugin",
              "docstring": "No documentation available",
              "signature": "(plugin: 'Plugin') -> 'None'",
              "parameters": [
                {
                  "name": "plugin",
                  "annotation": "Plugin",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "livekit.agents.plugin"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Plugin": {
          "name": "Plugin",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.plugin",
          "bases": [
            "ABC"
          ],
          "methods": {
            "register_plugin": {
              "name": "register_plugin",
              "docstring": "No documentation available",
              "signature": "(plugin: 'Plugin') -> 'None'",
              "parameters": [
                {
                  "name": "plugin",
                  "annotation": "Plugin",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "livekit.agents.plugin"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "STT": {
          "name": "STT",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.deepgram.stt",
          "bases": [
            "STT"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SpeechStream": {
          "name": "SpeechStream",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.deepgram.stt",
          "bases": [
            "RecognizeStream"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TTS": {
          "name": "TTS",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.deepgram.tts",
          "bases": [
            "TTS"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        }
      },
      "functions": {},
      "constants": {
        "NOT_IN_ALL": "['DeepgramPlugin', 'Plugin', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '_utils', 'log', 'logger', 'models', 'stt', 'tts', 'version']",
        "logger": "<Logger livekit.plugins.deepgram (WARNING)>",
        "n": "version"
      },
      "submodules": [
        "livekit.plugins.deepgram.log",
        "livekit.plugins.deepgram.models",
        "livekit.plugins.deepgram.stt",
        "livekit.plugins.deepgram.tts",
        "livekit.plugins.deepgram.version"
      ]
    },
    "livekit.plugins.openai": {
      "name": "livekit.plugins.openai",
      "docstring": "OpenAI plugin for LiveKit Agents\n\nSupport for OpenAI Realtime API, LLM, TTS, and STT APIs.\n\nAlso includes support for a large number of OpenAI-compatible APIs including Azure OpenAI, Cerebras,\nFireworks, Perplexity, Telnyx, xAI, Ollama, and DeepSeek.\n\nSee https://docs.livekit.io/agents/integrations/openai/ and\nhttps://docs.livekit.io/agents/integrations/llm/ for more information.",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\plugins\\openai\\__init__.py",
      "classes": {
        "EmbeddingData": {
          "name": "EmbeddingData",
          "docstring": "EmbeddingData(index: 'int', embedding: 'list[float]')",
          "module": "livekit.plugins.openai.embeddings",
          "bases": [
            "object"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "LLM": {
          "name": "LLM",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.openai.llm",
          "bases": [
            "LLM"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "LLMStream": {
          "name": "LLMStream",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.openai.llm",
          "bases": [
            "LLMStream"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "OpenAIPlugin": {
          "name": "OpenAIPlugin",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.openai",
          "bases": [
            "Plugin"
          ],
          "methods": {
            "register_plugin": {
              "name": "register_plugin",
              "docstring": "No documentation available",
              "signature": "(plugin: 'Plugin') -> 'None'",
              "parameters": [
                {
                  "name": "plugin",
                  "annotation": "Plugin",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "livekit.agents.plugin"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "Plugin": {
          "name": "Plugin",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.plugin",
          "bases": [
            "ABC"
          ],
          "methods": {
            "register_plugin": {
              "name": "register_plugin",
              "docstring": "No documentation available",
              "signature": "(plugin: 'Plugin') -> 'None'",
              "parameters": [
                {
                  "name": "plugin",
                  "annotation": "Plugin",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "livekit.agents.plugin"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "STT": {
          "name": "STT",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.openai.stt",
          "bases": [
            "STT"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "TTS": {
          "name": "TTS",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.openai.tts",
          "bases": [
            "TTS"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        }
      },
      "functions": {
        "create_embeddings": {
          "name": "create_embeddings",
          "docstring": "No documentation available",
          "signature": "(*, input: 'list[str]', model: 'models.EmbeddingModels' = 'text-embedding-3-small', dimensions: 'int | None' = None, api_key: 'str | None' = None, http_session: 'aiohttp.ClientSession | None' = None) -> 'list[EmbeddingData]'",
          "parameters": [
            {
              "name": "input",
              "annotation": "list[str]",
              "default": null,
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "model",
              "annotation": "models.EmbeddingModels",
              "default": "text-embedding-3-small",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dimensions",
              "annotation": "int | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "api_key",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "http_session",
              "annotation": "aiohttp.ClientSession | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "list[EmbeddingData]",
          "module": "livekit.plugins.openai.embeddings"
        }
      },
      "constants": {
        "NOT_IN_ALL": "['OpenAIPlugin', 'Plugin', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'embeddings', 'llm', 'log', 'logger', 'models', 'stt', 'tts', 'utils', 'version']",
        "logger": "<Logger livekit.plugins.openai (WARNING)>",
        "n": "version"
      },
      "submodules": [
        "livekit.plugins.openai.embeddings",
        "livekit.plugins.openai.llm",
        "livekit.plugins.openai.log",
        "livekit.plugins.openai.models",
        "livekit.plugins.openai.realtime",
        "livekit.plugins.openai.stt",
        "livekit.plugins.openai.tts",
        "livekit.plugins.openai.utils",
        "livekit.plugins.openai.version"
      ]
    },
    "livekit.plugins.silero": {
      "name": "livekit.plugins.silero",
      "docstring": "Silero VAD plugin for LiveKit Agents\n\nSee https://docs.livekit.io/agents/build/turns/vad/ for more information.",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\plugins\\silero\\__init__.py",
      "classes": {
        "Plugin": {
          "name": "Plugin",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.agents.plugin",
          "bases": [
            "ABC"
          ],
          "methods": {
            "register_plugin": {
              "name": "register_plugin",
              "docstring": "No documentation available",
              "signature": "(plugin: 'Plugin') -> 'None'",
              "parameters": [
                {
                  "name": "plugin",
                  "annotation": "Plugin",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "livekit.agents.plugin"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "SileroPlugin": {
          "name": "SileroPlugin",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.silero",
          "bases": [
            "Plugin"
          ],
          "methods": {
            "register_plugin": {
              "name": "register_plugin",
              "docstring": "No documentation available",
              "signature": "(plugin: 'Plugin') -> 'None'",
              "parameters": [
                {
                  "name": "plugin",
                  "annotation": "Plugin",
                  "default": null,
                  "kind": "POSITIONAL_OR_KEYWORD"
                }
              ],
              "return_annotation": "None",
              "module": "livekit.agents.plugin"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "VAD": {
          "name": "VAD",
          "docstring": "Silero Voice Activity Detection (VAD) class.\n\nThis class provides functionality to detect speech segments within audio data using the Silero VAD model.",
          "module": "livekit.plugins.silero.vad",
          "bases": [
            "VAD"
          ],
          "methods": {
            "load": {
              "name": "load",
              "docstring": "Load and initialize the Silero VAD model.\n\nThis method loads the ONNX model and prepares it for inference. When options are not provided,\nsane defaults are used.\n\n**Note:**\n    This method is blocking and may take time to load the model into memory.\n    It is recommended to call this method inside your prewarm mechanism.\n\n**Example:**\n\n    ```python\n    def prewarm(proc: JobProcess):\n        proc.userdata[\"vad\"] = silero.VAD.load()\n\n\n    async def entrypoint(ctx: JobContext):\n        vad = (ctx.proc.userdata[\"vad\"],)\n        # your agent logic...\n\n\n    if __name__ == \"__main__\":\n        cli.run_app(WorkerOptions(entrypoint_fnc=entrypoint, prewarm_fnc=prewarm))\n    ```\n\nArgs:\n    min_speech_duration (float): Minimum duration of speech to start a new speech chunk.\n    min_silence_duration (float): At the end of each speech, wait this duration before ending the speech.\n    prefix_padding_duration (float): Duration of padding to add to the beginning of each speech chunk.\n    max_buffered_speech (float): Maximum duration of speech to keep in the buffer (in seconds).\n    activation_threshold (float): Threshold to consider a frame as speech.\n    sample_rate (Literal[8000, 16000]): Sample rate for the inference (only 8KHz and 16KHz are supported).\n    force_cpu (bool): Force the use of CPU for inference.\n    padding_duration (float | None): **Deprecated**. Use `prefix_padding_duration` instead.\n\nReturns:\n    VAD: An instance of the VAD class ready for streaming.\n\nRaises:\n    ValueError: If an unsupported sample rate is provided.",
              "signature": "(*, min_speech_duration: 'float' = 0.05, min_silence_duration: 'float' = 0.55, prefix_padding_duration: 'float' = 0.5, max_buffered_speech: 'float' = 60.0, activation_threshold: 'float' = 0.5, sample_rate: 'Literal[8000, 16000]' = 16000, force_cpu: 'bool' = True, padding_duration: 'NotGivenOr[float]' = NOT_GIVEN) -> 'VAD'",
              "parameters": [
                {
                  "name": "min_speech_duration",
                  "annotation": "float",
                  "default": "0.05",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "min_silence_duration",
                  "annotation": "float",
                  "default": "0.55",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "prefix_padding_duration",
                  "annotation": "float",
                  "default": "0.5",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "max_buffered_speech",
                  "annotation": "float",
                  "default": "60.0",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "activation_threshold",
                  "annotation": "float",
                  "default": "0.5",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "sample_rate",
                  "annotation": "Literal[8000, 16000]",
                  "default": "16000",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "force_cpu",
                  "annotation": "bool",
                  "default": "True",
                  "kind": "KEYWORD_ONLY"
                },
                {
                  "name": "padding_duration",
                  "annotation": "NotGivenOr[float]",
                  "default": "NOT_GIVEN",
                  "kind": "KEYWORD_ONLY"
                }
              ],
              "return_annotation": "VAD",
              "module": "livekit.plugins.silero.vad"
            }
          },
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        },
        "VADStream": {
          "name": "VADStream",
          "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
          "module": "livekit.plugins.silero.vad",
          "bases": [
            "VADStream"
          ],
          "methods": {},
          "properties": {},
          "class_methods": {},
          "static_methods": {}
        }
      },
      "functions": {},
      "constants": {
        "NOT_IN_ALL": "['Plugin', 'SileroPlugin', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'log', 'logger', 'onnx_model', 'vad', 'version']",
        "logger": "<Logger livekit.plugins.silero (WARNING)>",
        "n": "version"
      },
      "submodules": [
        "livekit.plugins.silero.log",
        "livekit.plugins.silero.onnx_model",
        "livekit.plugins.silero.vad",
        "livekit.plugins.silero.version"
      ]
    },
    "livekit.protocol": {
      "name": "livekit.protocol",
      "docstring": "No documentation available",
      "file": "C:\\projects\\letta-voice\\venv\\Lib\\site-packages\\livekit\\protocol\\__init__.py",
      "classes": {},
      "functions": {},
      "constants": {},
      "submodules": [
        "livekit.protocol.agent",
        "livekit.protocol.agent_dispatch",
        "livekit.protocol.analytics",
        "livekit.protocol.egress",
        "livekit.protocol.ingress",
        "livekit.protocol.metrics",
        "livekit.protocol.models",
        "livekit.protocol.room",
        "livekit.protocol.sip",
        "livekit.protocol.version",
        "livekit.protocol.webhook"
      ]
    }
  },
  "classes": {
    "livekit.agents.APIConnectOptions": {
      "name": "APIConnectOptions",
      "docstring": "APIConnectOptions(max_retry: int = 3, retry_interval: float = 2.0, timeout: float = 10.0)",
      "module": "livekit.agents.types",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.APIConnectionError": {
      "name": "APIConnectionError",
      "docstring": "Raised when an API request failed due to a connection error.",
      "module": "livekit.agents._exceptions",
      "bases": [
        "APIError"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.APIError": {
      "name": "APIError",
      "docstring": "Raised when an API request failed.\nThis is used on our TTS/STT/LLM plugins.",
      "module": "livekit.agents._exceptions",
      "bases": [
        "Exception"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.APIStatusError": {
      "name": "APIStatusError",
      "docstring": "Raised when an API response has a status code of 4xx or 5xx.",
      "module": "livekit.agents._exceptions",
      "bases": [
        "APIError"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.APITimeoutError": {
      "name": "APITimeoutError",
      "docstring": "Raised when an API request timed out.",
      "module": "livekit.agents._exceptions",
      "bases": [
        "APIConnectionError"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.Agent": {
      "name": "Agent",
      "docstring": "No documentation available",
      "module": "livekit.agents.voice.agent",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.AgentSession": {
      "name": "AgentSession",
      "docstring": "Abstract base class for generic types.\n\nOn Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::\n\n    class Mapping[KT, VT]:\n        def __getitem__(self, key: KT) -> VT:\n            ...\n        # Etc.\n\nOn older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.\n\nAfter a class has been declared to be generic, it can then be used as\nfollows::\n\n    def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n        try:\n            return mapping[key]\n        except KeyError:\n            return default",
      "module": "livekit.agents.voice.agent_session",
      "bases": [
        "EventEmitter",
        "Generic"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.AgentStateChangedEvent": {
      "name": "AgentStateChangedEvent",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.voice.events",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.AssignmentTimeoutError": {
      "name": "AssignmentTimeoutError",
      "docstring": "Raised when accepting a job but not receiving an assignment within the specified timeout.\nThe server may have chosen another worker to handle this job.",
      "module": "livekit.agents._exceptions",
      "bases": [
        "Exception"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.AudioConfig": {
      "name": "AudioConfig",
      "docstring": "Definition for the audio to be played in the background\n\nArgs:\n    volume: The volume of the audio (0.0-1.0)\n    probability: The probability of the audio being played, when multiple\n        AudioConfigs are provided (0.0-1.0)",
      "module": "livekit.agents.voice.background_audio",
      "bases": [
        "tuple"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.AutoSubscribe": {
      "name": "AutoSubscribe",
      "docstring": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to 'utf-8'.\nerrors defaults to 'strict'.",
      "module": "livekit.agents.job",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.BackgroundAudioPlayer": {
      "name": "BackgroundAudioPlayer",
      "docstring": "No documentation available",
      "module": "livekit.agents.voice.background_audio",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.BuiltinAudioClip": {
      "name": "BuiltinAudioClip",
      "docstring": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
      "module": "livekit.agents.voice.background_audio",
      "bases": [
        "Enum"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.ChatContext": {
      "name": "ChatContext",
      "docstring": "No documentation available",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "object"
      ],
      "methods": {
        "empty": {
          "name": "empty",
          "docstring": "No documentation available",
          "signature": "() -> 'ChatContext'",
          "parameters": [],
          "return_annotation": "ChatContext",
          "module": "livekit.agents.llm.chat_context"
        },
        "from_dict": {
          "name": "from_dict",
          "docstring": "No documentation available",
          "signature": "(data: 'dict[str, Any]') -> 'ChatContext'",
          "parameters": [
            {
              "name": "data",
              "annotation": "dict[str, Any]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "ChatContext",
          "module": "livekit.agents.llm.chat_context"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.ChatMessage": {
      "name": "ChatMessage",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.CloseEvent": {
      "name": "CloseEvent",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.voice.events",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.ConversationItemAddedEvent": {
      "name": "ConversationItemAddedEvent",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.voice.events",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.ErrorEvent": {
      "name": "ErrorEvent",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.voice.events",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.FunctionCall": {
      "name": "FunctionCall",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.FunctionCallOutput": {
      "name": "FunctionCallOutput",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.FunctionTool": {
      "name": "FunctionTool",
      "docstring": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto[T](Protocol):\n        def meth(self) -> T:\n            ...",
      "module": "livekit.agents.llm.tool_context",
      "bases": [
        "Protocol"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.JobContext": {
      "name": "JobContext",
      "docstring": "No documentation available",
      "module": "livekit.agents.job",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.JobExecutorType": {
      "name": "JobExecutorType",
      "docstring": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
      "module": "livekit.agents.job",
      "bases": [
        "Enum"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.JobProcess": {
      "name": "JobProcess",
      "docstring": "No documentation available",
      "module": "livekit.agents.job",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.JobRequest": {
      "name": "JobRequest",
      "docstring": "No documentation available",
      "module": "livekit.agents.job",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.MetricsCollectedEvent": {
      "name": "MetricsCollectedEvent",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.voice.events",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.ModelSettings": {
      "name": "ModelSettings",
      "docstring": "ModelSettings(tool_choice: 'NotGivenOr[llm.ToolChoice]' = NOT_GIVEN)",
      "module": "livekit.agents.voice.agent",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.NotGiven": {
      "name": "NotGiven",
      "docstring": "No documentation available",
      "module": "livekit.agents.types",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.Plugin": {
      "name": "Plugin",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.plugin",
      "bases": [
        "ABC"
      ],
      "methods": {
        "register_plugin": {
          "name": "register_plugin",
          "docstring": "No documentation available",
          "signature": "(plugin: 'Plugin') -> 'None'",
          "parameters": [
            {
              "name": "plugin",
              "annotation": "Plugin",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "livekit.agents.plugin"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.RoomIO": {
      "name": "RoomIO",
      "docstring": "No documentation available",
      "module": "livekit.agents.voice.room_io.room_io",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.RoomInputOptions": {
      "name": "RoomInputOptions",
      "docstring": "RoomInputOptions(text_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, audio_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, video_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, audio_sample_rate: 'int' = 24000, audio_num_channels: 'int' = 1, noise_cancellation: 'rtc.NoiseCancellationOptions | None' = None, text_input_cb: 'TextInputCallback' = <function _default_text_input_cb at 0x00000192A8171F80>, participant_kinds: 'NotGivenOr[list[rtc.ParticipantKind.ValueType]]' = NOT_GIVEN, participant_identity: 'NotGivenOr[str]' = NOT_GIVEN, pre_connect_audio: 'bool' = True, pre_connect_audio_timeout: 'float' = 3.0, close_on_disconnect: 'bool' = True)",
      "module": "livekit.agents.voice.room_io.room_io",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.RoomOutputOptions": {
      "name": "RoomOutputOptions",
      "docstring": "RoomOutputOptions(transcription_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, audio_enabled: 'NotGivenOr[bool]' = NOT_GIVEN, audio_sample_rate: 'int' = 24000, audio_num_channels: 'int' = 1, audio_publish_options: 'rtc.TrackPublishOptions' = <factory>, sync_transcription: 'NotGivenOr[bool]' = NOT_GIVEN)",
      "module": "livekit.agents.voice.room_io.room_io",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.RunContext": {
      "name": "RunContext",
      "docstring": "Abstract base class for generic types.\n\nOn Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::\n\n    class Mapping[KT, VT]:\n        def __getitem__(self, key: KT) -> VT:\n            ...\n        # Etc.\n\nOn older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.\n\nAfter a class has been declared to be generic, it can then be used as\nfollows::\n\n    def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n        try:\n            return mapping[key]\n        except KeyError:\n            return default",
      "module": "livekit.agents.voice.events",
      "bases": [
        "Generic"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.SimulateJobInfo": {
      "name": "SimulateJobInfo",
      "docstring": "SimulateJobInfo(room: 'str', participant_identity: 'str | None' = None)",
      "module": "livekit.agents.worker",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.SpeechCreatedEvent": {
      "name": "SpeechCreatedEvent",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.voice.events",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.StopResponse": {
      "name": "StopResponse",
      "docstring": "Common base class for all non-exit exceptions.",
      "module": "livekit.agents.llm.tool_context",
      "bases": [
        "Exception"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.ToolError": {
      "name": "ToolError",
      "docstring": "Common base class for all non-exit exceptions.",
      "module": "livekit.agents.llm.tool_context",
      "bases": [
        "Exception"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.UserInputTranscribedEvent": {
      "name": "UserInputTranscribedEvent",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.voice.events",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.UserStateChangedEvent": {
      "name": "UserStateChangedEvent",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.voice.events",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.Worker": {
      "name": "Worker",
      "docstring": "Abstract base class for generic types.\n\nOn Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::\n\n    class Mapping[KT, VT]:\n        def __getitem__(self, key: KT) -> VT:\n            ...\n        # Etc.\n\nOn older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.\n\nAfter a class has been declared to be generic, it can then be used as\nfollows::\n\n    def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n        try:\n            return mapping[key]\n        except KeyError:\n            return default",
      "module": "livekit.agents.worker",
      "bases": [
        "EventEmitter"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.WorkerOptions": {
      "name": "WorkerOptions",
      "docstring": "WorkerOptions(entrypoint_fnc: 'Callable[[JobContext], Awaitable[None]]', request_fnc: 'Callable[[JobRequest], Awaitable[None]]' = <function _default_request_fnc at 0x00000192A7AB1E40>, prewarm_fnc: 'Callable[[JobProcess], Any]' = <function _default_initialize_process_fnc at 0x00000192A7834220>, load_fnc: 'Callable[[Worker], float] | Callable[[], float]' = <bound method _DefaultLoadCalc.get_load of <class 'livekit.agents.worker._DefaultLoadCalc'>>, job_executor_type: 'JobExecutorType' = <JobExecutorType.THREAD: 'thread'>, load_threshold: 'float | _WorkerEnvOption[float]' = _WorkerEnvOption(dev_default=inf, prod_default=0.75), job_memory_warn_mb: 'float' = 500, job_memory_limit_mb: 'float' = 0, drain_timeout: 'int' = 1800, num_idle_processes: 'int | _WorkerEnvOption[int]' = _WorkerEnvOption(dev_default=0, prod_default=22), shutdown_process_timeout: 'float' = 60.0, initialize_process_timeout: 'float' = 10.0, permissions: 'WorkerPermissions' = <factory>, agent_name: 'str' = '', worker_type: 'WorkerType' = <WorkerType.ROOM: 0>, max_retry: 'int' = 16, ws_url: 'str' = 'ws://localhost:7880', api_key: 'str | None' = None, api_secret: 'str | None' = None, _worker_token: 'str | None' = None, host: 'str' = '', port: 'int | _WorkerEnvOption[int]' = _WorkerEnvOption(dev_default=0, prod_default=8081), http_proxy: 'NotGivenOr[str | None]' = NOT_GIVEN, multiprocessing_context: \"Literal['spawn', 'forkserver']\" = 'spawn')",
      "module": "livekit.agents.worker",
      "bases": [
        "object"
      ],
      "methods": {
        "load_fnc": {
          "name": "get_load",
          "docstring": "No documentation available",
          "signature": "(worker: 'Worker') -> 'float'",
          "parameters": [
            {
              "name": "worker",
              "annotation": "Worker",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "float",
          "module": "livekit.agents.worker"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.WorkerPermissions": {
      "name": "WorkerPermissions",
      "docstring": "WorkerPermissions(can_publish: 'bool' = True, can_subscribe: 'bool' = True, can_publish_data: 'bool' = True, can_update_metadata: 'bool' = True, can_publish_sources: 'list[models.TrackSource]' = <factory>, hidden: 'bool' = False)",
      "module": "livekit.agents.worker",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.WorkerType": {
      "name": "WorkerType",
      "docstring": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
      "module": "livekit.agents.worker",
      "bases": [
        "Enum"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.AudioContent": {
      "name": "AudioContent",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.AvailabilityChangedEvent": {
      "name": "AvailabilityChangedEvent",
      "docstring": "AvailabilityChangedEvent(llm: 'LLM', available: 'bool')",
      "module": "livekit.agents.llm.fallback_adapter",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.ChatChunk": {
      "name": "ChatChunk",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.llm",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.ChatContext": {
      "name": "ChatContext",
      "docstring": "No documentation available",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "object"
      ],
      "methods": {
        "empty": {
          "name": "empty",
          "docstring": "No documentation available",
          "signature": "() -> 'ChatContext'",
          "parameters": [],
          "return_annotation": "ChatContext",
          "module": "livekit.agents.llm.chat_context"
        },
        "from_dict": {
          "name": "from_dict",
          "docstring": "No documentation available",
          "signature": "(data: 'dict[str, Any]') -> 'ChatContext'",
          "parameters": [
            {
              "name": "data",
              "annotation": "dict[str, Any]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "ChatContext",
          "module": "livekit.agents.llm.chat_context"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.ChatMessage": {
      "name": "ChatMessage",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.ChoiceDelta": {
      "name": "ChoiceDelta",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.llm",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.CompletionUsage": {
      "name": "CompletionUsage",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.llm",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.FallbackAdapter": {
      "name": "FallbackAdapter",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.llm.fallback_adapter",
      "bases": [
        "LLM"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.FunctionCall": {
      "name": "FunctionCall",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.FunctionCallOutput": {
      "name": "FunctionCallOutput",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.FunctionTool": {
      "name": "FunctionTool",
      "docstring": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto[T](Protocol):\n        def meth(self) -> T:\n            ...",
      "module": "livekit.agents.llm.tool_context",
      "bases": [
        "Protocol"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.FunctionToolCall": {
      "name": "FunctionToolCall",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.llm",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.GenerationCreatedEvent": {
      "name": "GenerationCreatedEvent",
      "docstring": "GenerationCreatedEvent(message_stream: 'AsyncIterable[MessageGeneration]', function_stream: 'AsyncIterable[FunctionCall]', user_initiated: 'bool')",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.ImageContent": {
      "name": "ImageContent",
      "docstring": "ImageContent is used to input images into the ChatContext on supported LLM providers / plugins.\n\nYou may need to consult your LLM provider's documentation on supported URL types.\n\n```python\n# Pass a VideoFrame directly, which will be automatically converted to a JPEG data URL internally\nasync for event in rtc.VideoStream(video_track):\n    chat_image = ImageContent(image=event.frame)\n    # this instance is now available for your ChatContext\n\n# Encode your VideoFrame yourself for more control, and pass the result as a data URL (see EncodeOptions for more details)\nfrom livekit.agents.utils.images import encode, EncodeOptions, ResizeOptions\n\nimage_bytes = encode(\n    event.frame,\n    EncodeOptions(\n        format=\"PNG\",\n        resize_options=ResizeOptions(width=512, height=512, strategy=\"scale_aspect_fit\"),\n    ),\n)\nchat_image = ImageContent(\n    image=f\"data:image/png;base64,{base64.b64encode(image_bytes).decode('utf-8')}\"\n)\n\n# With an external URL\nchat_image = ImageContent(image=\"https://example.com/image.jpg\")\n```",
      "module": "livekit.agents.llm.chat_context",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.InputSpeechStartedEvent": {
      "name": "InputSpeechStartedEvent",
      "docstring": "InputSpeechStartedEvent()",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.InputSpeechStoppedEvent": {
      "name": "InputSpeechStoppedEvent",
      "docstring": "InputSpeechStoppedEvent(user_transcription_enabled: 'bool')",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.InputTranscriptionCompleted": {
      "name": "InputTranscriptionCompleted",
      "docstring": "InputTranscriptionCompleted(item_id: 'str', transcript: 'str', is_final: 'bool')",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.LLM": {
      "name": "LLM",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.llm.llm",
      "bases": [
        "ABC",
        "EventEmitter",
        "Generic"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.LLMError": {
      "name": "LLMError",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.llm",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.LLMStream": {
      "name": "LLMStream",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.llm.llm",
      "bases": [
        "ABC"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.MessageGeneration": {
      "name": "MessageGeneration",
      "docstring": "MessageGeneration(message_id: 'str', text_stream: 'AsyncIterable[str]', audio_stream: 'AsyncIterable[rtc.AudioFrame]')",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.RawFunctionTool": {
      "name": "RawFunctionTool",
      "docstring": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto[T](Protocol):\n        def meth(self) -> T:\n            ...",
      "module": "livekit.agents.llm.tool_context",
      "bases": [
        "Protocol"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.RealtimeCapabilities": {
      "name": "RealtimeCapabilities",
      "docstring": "RealtimeCapabilities(message_truncation: 'bool', turn_detection: 'bool', user_transcription: 'bool', auto_tool_reply_generation: 'bool')",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.RealtimeError": {
      "name": "RealtimeError",
      "docstring": "Common base class for all non-exit exceptions.",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "Exception"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.RealtimeModel": {
      "name": "RealtimeModel",
      "docstring": "No documentation available",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.RealtimeModelError": {
      "name": "RealtimeModelError",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.RealtimeSession": {
      "name": "RealtimeSession",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "ABC",
        "EventEmitter",
        "Generic"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.RealtimeSessionReconnectedEvent": {
      "name": "RealtimeSessionReconnectedEvent",
      "docstring": "RealtimeSessionReconnectedEvent()",
      "module": "livekit.agents.llm.realtime",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.StopResponse": {
      "name": "StopResponse",
      "docstring": "Common base class for all non-exit exceptions.",
      "module": "livekit.agents.llm.tool_context",
      "bases": [
        "Exception"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.ToolContext": {
      "name": "ToolContext",
      "docstring": "Stateless container for a set of AI functions",
      "module": "livekit.agents.llm.tool_context",
      "bases": [
        "object"
      ],
      "methods": {
        "empty": {
          "name": "empty",
          "docstring": "No documentation available",
          "signature": "() -> 'ToolContext'",
          "parameters": [],
          "return_annotation": "ToolContext",
          "module": "livekit.agents.llm.tool_context"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.llm.ToolError": {
      "name": "ToolError",
      "docstring": "Common base class for all non-exit exceptions.",
      "module": "livekit.agents.llm.tool_context",
      "bases": [
        "Exception"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.AvailabilityChangedEvent": {
      "name": "AvailabilityChangedEvent",
      "docstring": "AvailabilityChangedEvent(stt: 'STT', available: 'bool')",
      "module": "livekit.agents.stt.fallback_adapter",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.FallbackAdapter": {
      "name": "FallbackAdapter",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.stt.fallback_adapter",
      "bases": [
        "STT"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.RecognitionUsage": {
      "name": "RecognitionUsage",
      "docstring": "RecognitionUsage(audio_duration: 'float')",
      "module": "livekit.agents.stt.stt",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.RecognizeStream": {
      "name": "RecognizeStream",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.stt.stt",
      "bases": [
        "ABC"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.STT": {
      "name": "STT",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.stt.stt",
      "bases": [
        "ABC",
        "EventEmitter",
        "Generic"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.STTCapabilities": {
      "name": "STTCapabilities",
      "docstring": "STTCapabilities(streaming: 'bool', interim_results: 'bool')",
      "module": "livekit.agents.stt.stt",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.STTError": {
      "name": "STTError",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.stt.stt",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.SpeechData": {
      "name": "SpeechData",
      "docstring": "SpeechData(language: 'str', text: 'str', start_time: 'float' = 0.0, end_time: 'float' = 0.0, confidence: 'float' = 0.0, speaker_id: 'str | None' = None)",
      "module": "livekit.agents.stt.stt",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.SpeechEvent": {
      "name": "SpeechEvent",
      "docstring": "SpeechEvent(type: 'SpeechEventType', request_id: 'str' = '', alternatives: 'list[SpeechData]' = <factory>, recognition_usage: 'RecognitionUsage | None' = None)",
      "module": "livekit.agents.stt.stt",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.SpeechEventType": {
      "name": "SpeechEventType",
      "docstring": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to 'utf-8'.\nerrors defaults to 'strict'.",
      "module": "livekit.agents.stt.stt",
      "bases": [
        "str",
        "Enum"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.SpeechStream": {
      "name": "RecognizeStream",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.stt.stt",
      "bases": [
        "ABC"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.StreamAdapter": {
      "name": "StreamAdapter",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.stt.stream_adapter",
      "bases": [
        "STT"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.stt.StreamAdapterWrapper": {
      "name": "StreamAdapterWrapper",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.stt.stream_adapter",
      "bases": [
        "RecognizeStream"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.AudioEmitter": {
      "name": "AudioEmitter",
      "docstring": "No documentation available",
      "module": "livekit.agents.tts.tts",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.AvailabilityChangedEvent": {
      "name": "AvailabilityChangedEvent",
      "docstring": "AvailabilityChangedEvent(tts: 'TTS', available: 'bool')",
      "module": "livekit.agents.tts.fallback_adapter",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.ChunkedStream": {
      "name": "ChunkedStream",
      "docstring": "Used by the non-streamed synthesize API, some providers support chunked http responses",
      "module": "livekit.agents.tts.tts",
      "bases": [
        "ABC"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.FallbackAdapter": {
      "name": "FallbackAdapter",
      "docstring": "Manages multiple TTS instances, providing a fallback mechanism to ensure continuous TTS service.",
      "module": "livekit.agents.tts.fallback_adapter",
      "bases": [
        "TTS"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.FallbackChunkedStream": {
      "name": "FallbackChunkedStream",
      "docstring": "Used by the non-streamed synthesize API, some providers support chunked http responses",
      "module": "livekit.agents.tts.fallback_adapter",
      "bases": [
        "ChunkedStream"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.FallbackSynthesizeStream": {
      "name": "FallbackSynthesizeStream",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.tts.fallback_adapter",
      "bases": [
        "SynthesizeStream"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.StreamAdapter": {
      "name": "StreamAdapter",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.tts.stream_adapter",
      "bases": [
        "TTS"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.StreamAdapterWrapper": {
      "name": "StreamAdapterWrapper",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.tts.stream_adapter",
      "bases": [
        "SynthesizeStream"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.SynthesizeStream": {
      "name": "SynthesizeStream",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.tts.tts",
      "bases": [
        "ABC"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.SynthesizedAudio": {
      "name": "SynthesizedAudio",
      "docstring": "SynthesizedAudio(frame: 'rtc.AudioFrame', request_id: 'str', is_final: 'bool' = False, segment_id: 'str' = '', delta_text: 'str' = '')",
      "module": "livekit.agents.tts.tts",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.TTS": {
      "name": "TTS",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.tts.tts",
      "bases": [
        "ABC",
        "EventEmitter",
        "Generic"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.TTSCapabilities": {
      "name": "TTSCapabilities",
      "docstring": "TTSCapabilities(streaming: 'bool')",
      "module": "livekit.agents.tts.tts",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.agents.tts.TTSError": {
      "name": "TTSError",
      "docstring": "!!! abstract \"Usage Documentation\"\n    [Models](../concepts/models.md)\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "module": "livekit.agents.tts.tts",
      "bases": [
        "BaseModel"
      ],
      "methods": {
        "construct": {
          "name": "construct",
          "docstring": "No documentation available",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "from_orm": {
          "name": "from_orm",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_construct": {
          "name": "model_construct",
          "docstring": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data.",
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "_fields_set",
              "annotation": "set[str] | None",
              "default": "None",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "values",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_json_schema": {
          "name": "model_json_schema",
          "docstring": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class.",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "schema_generator",
              "annotation": "type[GenerateJsonSchema]",
              "default": "<class 'pydantic.json_schema.GenerateJsonSchema'>",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "mode",
              "annotation": "JsonSchemaMode",
              "default": "validation",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "dict[str, Any]",
          "module": "pydantic.main"
        },
        "model_parametrized_name": {
          "name": "model_parametrized_name",
          "docstring": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models.",
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "parameters": [
            {
              "name": "params",
              "annotation": "tuple[type[Any], ...]",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "model_rebuild": {
          "name": "model_rebuild",
          "docstring": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.",
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "parameters": [
            {
              "name": "force",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "raise_errors",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_parent_namespace_depth",
              "annotation": "int",
              "default": "2",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "_types_namespace",
              "annotation": "MappingNamespace | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "bool | None",
          "module": "pydantic.main"
        },
        "model_validate": {
          "name": "model_validate",
          "docstring": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "from_attributes",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_json": {
          "name": "model_validate_json",
          "docstring": "!!! abstract \"Usage Documentation\"\n    [JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated.",
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "json_data",
              "annotation": "str | bytes | bytearray",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "model_validate_strings": {
          "name": "model_validate_strings",
          "docstring": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n    by_alias: Whether to use the field's alias when validating against the provided input data.\n    by_name: Whether to use the field's name when validating against the provided input data.\n\nReturns:\n    The validated Pydantic model.",
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "strict",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "context",
              "annotation": "Any | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_alias",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "by_name",
              "annotation": "bool | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_file": {
          "name": "parse_file",
          "docstring": "No documentation available",
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "path",
              "annotation": "str | Path",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_obj": {
          "name": "parse_obj",
          "docstring": "No documentation available",
          "signature": "(obj: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "obj",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "parse_raw": {
          "name": "parse_raw",
          "docstring": "No documentation available",
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "parameters": [
            {
              "name": "b",
              "annotation": "str | bytes",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "content_type",
              "annotation": "str | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "encoding",
              "annotation": "str",
              "default": "utf8",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "proto",
              "annotation": "DeprecatedParseProtocol | None",
              "default": "None",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "allow_pickle",
              "annotation": "bool",
              "default": "False",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        },
        "schema": {
          "name": "schema",
          "docstring": "No documentation available",
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "POSITIONAL_OR_KEYWORD"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Dict[str, Any]",
          "module": "pydantic.main"
        },
        "schema_json": {
          "name": "schema_json",
          "docstring": "No documentation available",
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "parameters": [
            {
              "name": "by_alias",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "ref_template",
              "annotation": "str",
              "default": "#/$defs/{model}",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "dumps_kwargs",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "str",
          "module": "pydantic.main"
        },
        "update_forward_refs": {
          "name": "update_forward_refs",
          "docstring": "No documentation available",
          "signature": "(**localns: 'Any') -> 'None'",
          "parameters": [
            {
              "name": "localns",
              "annotation": "Any",
              "default": null,
              "kind": "VAR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "pydantic.main"
        },
        "validate": {
          "name": "validate",
          "docstring": "No documentation available",
          "signature": "(value: 'Any') -> 'Self'",
          "parameters": [
            {
              "name": "value",
              "annotation": "Any",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "Self",
          "module": "pydantic.main"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.AccessToken": {
      "name": "AccessToken",
      "docstring": "No documentation available",
      "module": "livekit.api.access_token",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ActiveSpeakerUpdate": {
      "name": "ActiveSpeakerUpdate",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.AgentDispatch": {
      "name": "AgentDispatch",
      "docstring": "A ProtocolMessage",
      "module": "agent_dispatch",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.AgentDispatchState": {
      "name": "AgentDispatchState",
      "docstring": "A ProtocolMessage",
      "module": "agent_dispatch",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.AliOSSUpload": {
      "name": "AliOSSUpload",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.AutoParticipantEgress": {
      "name": "AutoParticipantEgress",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.AutoTrackEgress": {
      "name": "AutoTrackEgress",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.AvailabilityRequest": {
      "name": "AvailabilityRequest",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.AvailabilityResponse": {
      "name": "AvailabilityResponse",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.AzureBlobUpload": {
      "name": "AzureBlobUpload",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ChatMessage": {
      "name": "ChatMessage",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ClientConfiguration": {
      "name": "ClientConfiguration",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ClientInfo": {
      "name": "ClientInfo",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.Codec": {
      "name": "Codec",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.CreateAgentDispatchRequest": {
      "name": "CreateAgentDispatchRequest",
      "docstring": "A ProtocolMessage",
      "module": "agent_dispatch",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.CreateIngressRequest": {
      "name": "CreateIngressRequest",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.CreateRoomRequest": {
      "name": "CreateRoomRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.CreateSIPDispatchRuleRequest": {
      "name": "CreateSIPDispatchRuleRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.CreateSIPInboundTrunkRequest": {
      "name": "CreateSIPInboundTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.CreateSIPOutboundTrunkRequest": {
      "name": "CreateSIPOutboundTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.CreateSIPParticipantRequest": {
      "name": "CreateSIPParticipantRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.CreateSIPTrunkRequest": {
      "name": "CreateSIPTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DataPacket": {
      "name": "DataPacket",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DataStream": {
      "name": "DataStream",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DeleteAgentDispatchRequest": {
      "name": "DeleteAgentDispatchRequest",
      "docstring": "A ProtocolMessage",
      "module": "agent_dispatch",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DeleteIngressRequest": {
      "name": "DeleteIngressRequest",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DeleteRoomRequest": {
      "name": "DeleteRoomRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DeleteRoomResponse": {
      "name": "DeleteRoomResponse",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DeleteSIPDispatchRuleRequest": {
      "name": "DeleteSIPDispatchRuleRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DeleteSIPTrunkRequest": {
      "name": "DeleteSIPTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DirectFileOutput": {
      "name": "DirectFileOutput",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.DisabledCodecs": {
      "name": "DisabledCodecs",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.EgressInfo": {
      "name": "EgressInfo",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.EncodedFileOutput": {
      "name": "EncodedFileOutput",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.EncodingOptions": {
      "name": "EncodingOptions",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.Encryption": {
      "name": "Encryption",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.FileInfo": {
      "name": "FileInfo",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ForwardParticipantRequest": {
      "name": "ForwardParticipantRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ForwardParticipantResponse": {
      "name": "ForwardParticipantResponse",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.GCPUpload": {
      "name": "GCPUpload",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.GetSIPInboundTrunkRequest": {
      "name": "GetSIPInboundTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.GetSIPInboundTrunkResponse": {
      "name": "GetSIPInboundTrunkResponse",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.GetSIPOutboundTrunkRequest": {
      "name": "GetSIPOutboundTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.GetSIPOutboundTrunkResponse": {
      "name": "GetSIPOutboundTrunkResponse",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ImageOutput": {
      "name": "ImageOutput",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ImagesInfo": {
      "name": "ImagesInfo",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.IngressAudioEncodingOptions": {
      "name": "IngressAudioEncodingOptions",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.IngressAudioOptions": {
      "name": "IngressAudioOptions",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.IngressInfo": {
      "name": "IngressInfo",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.IngressState": {
      "name": "IngressState",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.IngressVideoEncodingOptions": {
      "name": "IngressVideoEncodingOptions",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.IngressVideoOptions": {
      "name": "IngressVideoOptions",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.InputAudioState": {
      "name": "InputAudioState",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.InputVideoState": {
      "name": "InputVideoState",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.Job": {
      "name": "Job",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.JobAssignment": {
      "name": "JobAssignment",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.JobState": {
      "name": "JobState",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.JobTermination": {
      "name": "JobTermination",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListAgentDispatchRequest": {
      "name": "ListAgentDispatchRequest",
      "docstring": "A ProtocolMessage",
      "module": "agent_dispatch",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListAgentDispatchResponse": {
      "name": "ListAgentDispatchResponse",
      "docstring": "A ProtocolMessage",
      "module": "agent_dispatch",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListEgressRequest": {
      "name": "ListEgressRequest",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListEgressResponse": {
      "name": "ListEgressResponse",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListIngressRequest": {
      "name": "ListIngressRequest",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListIngressResponse": {
      "name": "ListIngressResponse",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListParticipantsRequest": {
      "name": "ListParticipantsRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListParticipantsResponse": {
      "name": "ListParticipantsResponse",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListRoomsRequest": {
      "name": "ListRoomsRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListRoomsResponse": {
      "name": "ListRoomsResponse",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListSIPDispatchRuleRequest": {
      "name": "ListSIPDispatchRuleRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListSIPDispatchRuleResponse": {
      "name": "ListSIPDispatchRuleResponse",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListSIPInboundTrunkRequest": {
      "name": "ListSIPInboundTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListSIPInboundTrunkResponse": {
      "name": "ListSIPInboundTrunkResponse",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListSIPOutboundTrunkRequest": {
      "name": "ListSIPOutboundTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListSIPOutboundTrunkResponse": {
      "name": "ListSIPOutboundTrunkResponse",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListSIPTrunkRequest": {
      "name": "ListSIPTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListSIPTrunkResponse": {
      "name": "ListSIPTrunkResponse",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ListUpdate": {
      "name": "ListUpdate",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.LiveKitAPI": {
      "name": "LiveKitAPI",
      "docstring": "LiveKit Server API Client\n\nThis class is the main entrypoint, which exposes all services.\n\nUsage:\n\n```python\nfrom livekit import api\nlkapi = api.LiveKitAPI()\nrooms = await lkapi.room.list_rooms(api.proto_room.ListRoomsRequest(names=['test-room']))\n```",
      "module": "livekit.api.livekit_api",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.MigrateJobRequest": {
      "name": "MigrateJobRequest",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.MoveParticipantRequest": {
      "name": "MoveParticipantRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.MoveParticipantResponse": {
      "name": "MoveParticipantResponse",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.MuteRoomTrackRequest": {
      "name": "MuteRoomTrackRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.MuteRoomTrackResponse": {
      "name": "MuteRoomTrackResponse",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.Pagination": {
      "name": "Pagination",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ParticipantEgressRequest": {
      "name": "ParticipantEgressRequest",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ParticipantInfo": {
      "name": "ParticipantInfo",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ParticipantPermission": {
      "name": "ParticipantPermission",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ParticipantTracks": {
      "name": "ParticipantTracks",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.PlayoutDelay": {
      "name": "PlayoutDelay",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ProxyConfig": {
      "name": "ProxyConfig",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RTCPSenderReportState": {
      "name": "RTCPSenderReportState",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RTPDrift": {
      "name": "RTPDrift",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RTPForwarderState": {
      "name": "RTPForwarderState",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RTPMungerState": {
      "name": "RTPMungerState",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RTPStats": {
      "name": "RTPStats",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RegisterWorkerRequest": {
      "name": "RegisterWorkerRequest",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RegisterWorkerResponse": {
      "name": "RegisterWorkerResponse",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RemoveParticipantResponse": {
      "name": "RemoveParticipantResponse",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.Room": {
      "name": "Room",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RoomAgent": {
      "name": "RoomAgent",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RoomAgentDispatch": {
      "name": "RoomAgentDispatch",
      "docstring": "A ProtocolMessage",
      "module": "agent_dispatch",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RoomCompositeEgressRequest": {
      "name": "RoomCompositeEgressRequest",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RoomConfiguration": {
      "name": "RoomConfiguration",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RoomEgress": {
      "name": "RoomEgress",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RoomParticipantIdentity": {
      "name": "RoomParticipantIdentity",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RpcAck": {
      "name": "RpcAck",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RpcError": {
      "name": "RpcError",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RpcRequest": {
      "name": "RpcRequest",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.RpcResponse": {
      "name": "RpcResponse",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.S3Upload": {
      "name": "S3Upload",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPCallInfo": {
      "name": "SIPCallInfo",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPDispatchRule": {
      "name": "SIPDispatchRule",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPDispatchRuleCallee": {
      "name": "SIPDispatchRuleCallee",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPDispatchRuleDirect": {
      "name": "SIPDispatchRuleDirect",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPDispatchRuleIndividual": {
      "name": "SIPDispatchRuleIndividual",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPDispatchRuleInfo": {
      "name": "SIPDispatchRuleInfo",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPDispatchRuleUpdate": {
      "name": "SIPDispatchRuleUpdate",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPGrants": {
      "name": "SIPGrants",
      "docstring": "SIPGrants(admin: bool = False, call: bool = False)",
      "module": "livekit.api.access_token",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPInboundTrunkInfo": {
      "name": "SIPInboundTrunkInfo",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPInboundTrunkUpdate": {
      "name": "SIPInboundTrunkUpdate",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPOutboundConfig": {
      "name": "SIPOutboundConfig",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPOutboundTrunkInfo": {
      "name": "SIPOutboundTrunkInfo",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPOutboundTrunkUpdate": {
      "name": "SIPOutboundTrunkUpdate",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPParticipantInfo": {
      "name": "SIPParticipantInfo",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPStatus": {
      "name": "SIPStatus",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPTransferInfo": {
      "name": "SIPTransferInfo",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPTrunkInfo": {
      "name": "SIPTrunkInfo",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SIPUri": {
      "name": "SIPUri",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SegmentedFileOutput": {
      "name": "SegmentedFileOutput",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SegmentsInfo": {
      "name": "SegmentsInfo",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SendDataRequest": {
      "name": "SendDataRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SendDataResponse": {
      "name": "SendDataResponse",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ServerInfo": {
      "name": "ServerInfo",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.ServerMessage": {
      "name": "ServerMessage",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SimulateJobRequest": {
      "name": "SimulateJobRequest",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SimulcastCodecInfo": {
      "name": "SimulcastCodecInfo",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SipDTMF": {
      "name": "SipDTMF",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.SpeakerInfo": {
      "name": "SpeakerInfo",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.StopEgressRequest": {
      "name": "StopEgressRequest",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.StreamInfo": {
      "name": "StreamInfo",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.StreamInfoList": {
      "name": "StreamInfoList",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.StreamOutput": {
      "name": "StreamOutput",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.TimedVersion": {
      "name": "TimedVersion",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.TokenVerifier": {
      "name": "TokenVerifier",
      "docstring": "No documentation available",
      "module": "livekit.api.access_token",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.TrackCompositeEgressRequest": {
      "name": "TrackCompositeEgressRequest",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.TrackEgressRequest": {
      "name": "TrackEgressRequest",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.TrackInfo": {
      "name": "TrackInfo",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.Transcription": {
      "name": "Transcription",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.TranscriptionSegment": {
      "name": "TranscriptionSegment",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.TransferSIPParticipantRequest": {
      "name": "TransferSIPParticipantRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.TwirpError": {
      "name": "TwirpError",
      "docstring": "Common base class for all non-exit exceptions.",
      "module": "livekit.api.twirp_client",
      "bases": [
        "Exception"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.TwirpErrorCode": {
      "name": "TwirpErrorCode",
      "docstring": "No documentation available",
      "module": "livekit.api.twirp_client",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateIngressRequest": {
      "name": "UpdateIngressRequest",
      "docstring": "A ProtocolMessage",
      "module": "ingress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateJobStatus": {
      "name": "UpdateJobStatus",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateLayoutRequest": {
      "name": "UpdateLayoutRequest",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateParticipantRequest": {
      "name": "UpdateParticipantRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateRoomMetadataRequest": {
      "name": "UpdateRoomMetadataRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateSIPDispatchRuleRequest": {
      "name": "UpdateSIPDispatchRuleRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateSIPInboundTrunkRequest": {
      "name": "UpdateSIPInboundTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateSIPOutboundTrunkRequest": {
      "name": "UpdateSIPOutboundTrunkRequest",
      "docstring": "A ProtocolMessage",
      "module": "sip",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateStreamRequest": {
      "name": "UpdateStreamRequest",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateSubscriptionsRequest": {
      "name": "UpdateSubscriptionsRequest",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateSubscriptionsResponse": {
      "name": "UpdateSubscriptionsResponse",
      "docstring": "A ProtocolMessage",
      "module": "room",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UpdateWorkerStatus": {
      "name": "UpdateWorkerStatus",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.UserPacket": {
      "name": "UserPacket",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.VP8MungerState": {
      "name": "VP8MungerState",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.VideoConfiguration": {
      "name": "VideoConfiguration",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.VideoGrants": {
      "name": "VideoGrants",
      "docstring": "VideoGrants(room_create: Optional[bool] = None, room_list: Optional[bool] = None, room_record: Optional[bool] = None, room_admin: Optional[bool] = None, room_join: Optional[bool] = None, room: str = '', can_publish: bool = True, can_subscribe: bool = True, can_publish_data: bool = True, can_publish_sources: Optional[List[str]] = None, can_update_own_metadata: Optional[bool] = None, ingress_admin: Optional[bool] = None, hidden: Optional[bool] = None, recorder: Optional[bool] = None, agent: Optional[bool] = None)",
      "module": "livekit.api.access_token",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.VideoLayer": {
      "name": "VideoLayer",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.WebEgressRequest": {
      "name": "WebEgressRequest",
      "docstring": "A ProtocolMessage",
      "module": "egress",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.WebhookConfig": {
      "name": "WebhookConfig",
      "docstring": "A ProtocolMessage",
      "module": "models",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.WebhookEvent": {
      "name": "WebhookEvent",
      "docstring": "A ProtocolMessage",
      "module": "webhook",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.WebhookReceiver": {
      "name": "WebhookReceiver",
      "docstring": "No documentation available",
      "module": "livekit.api.webhook",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.WorkerMessage": {
      "name": "WorkerMessage",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.WorkerPing": {
      "name": "WorkerPing",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.api.WorkerPong": {
      "name": "WorkerPong",
      "docstring": "A ProtocolMessage",
      "module": "agent",
      "bases": [
        "Message",
        "Message"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.cartesia.CartesiaPlugin": {
      "name": "CartesiaPlugin",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.cartesia",
      "bases": [
        "Plugin"
      ],
      "methods": {
        "register_plugin": {
          "name": "register_plugin",
          "docstring": "No documentation available",
          "signature": "(plugin: 'Plugin') -> 'None'",
          "parameters": [
            {
              "name": "plugin",
              "annotation": "Plugin",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "livekit.agents.plugin"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.cartesia.ChunkedStream": {
      "name": "ChunkedStream",
      "docstring": "Synthesize chunked text using the bytes endpoint",
      "module": "livekit.plugins.cartesia.tts",
      "bases": [
        "ChunkedStream"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.cartesia.Plugin": {
      "name": "Plugin",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.plugin",
      "bases": [
        "ABC"
      ],
      "methods": {
        "register_plugin": {
          "name": "register_plugin",
          "docstring": "No documentation available",
          "signature": "(plugin: 'Plugin') -> 'None'",
          "parameters": [
            {
              "name": "plugin",
              "annotation": "Plugin",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "livekit.agents.plugin"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.cartesia.STT": {
      "name": "STT",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.cartesia.stt",
      "bases": [
        "STT"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.cartesia.TTS": {
      "name": "TTS",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.cartesia.tts",
      "bases": [
        "TTS"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.deepgram.AudioEnergyFilter": {
      "name": "AudioEnergyFilter",
      "docstring": "No documentation available",
      "module": "livekit.plugins.deepgram.stt",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.deepgram.DeepgramPlugin": {
      "name": "DeepgramPlugin",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.deepgram",
      "bases": [
        "Plugin"
      ],
      "methods": {
        "register_plugin": {
          "name": "register_plugin",
          "docstring": "No documentation available",
          "signature": "(plugin: 'Plugin') -> 'None'",
          "parameters": [
            {
              "name": "plugin",
              "annotation": "Plugin",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "livekit.agents.plugin"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.deepgram.Plugin": {
      "name": "Plugin",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.plugin",
      "bases": [
        "ABC"
      ],
      "methods": {
        "register_plugin": {
          "name": "register_plugin",
          "docstring": "No documentation available",
          "signature": "(plugin: 'Plugin') -> 'None'",
          "parameters": [
            {
              "name": "plugin",
              "annotation": "Plugin",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "livekit.agents.plugin"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.deepgram.STT": {
      "name": "STT",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.deepgram.stt",
      "bases": [
        "STT"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.deepgram.SpeechStream": {
      "name": "SpeechStream",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.deepgram.stt",
      "bases": [
        "RecognizeStream"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.deepgram.TTS": {
      "name": "TTS",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.deepgram.tts",
      "bases": [
        "TTS"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.openai.EmbeddingData": {
      "name": "EmbeddingData",
      "docstring": "EmbeddingData(index: 'int', embedding: 'list[float]')",
      "module": "livekit.plugins.openai.embeddings",
      "bases": [
        "object"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.openai.LLM": {
      "name": "LLM",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.openai.llm",
      "bases": [
        "LLM"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.openai.LLMStream": {
      "name": "LLMStream",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.openai.llm",
      "bases": [
        "LLMStream"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.openai.OpenAIPlugin": {
      "name": "OpenAIPlugin",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.openai",
      "bases": [
        "Plugin"
      ],
      "methods": {
        "register_plugin": {
          "name": "register_plugin",
          "docstring": "No documentation available",
          "signature": "(plugin: 'Plugin') -> 'None'",
          "parameters": [
            {
              "name": "plugin",
              "annotation": "Plugin",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "livekit.agents.plugin"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.openai.Plugin": {
      "name": "Plugin",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.plugin",
      "bases": [
        "ABC"
      ],
      "methods": {
        "register_plugin": {
          "name": "register_plugin",
          "docstring": "No documentation available",
          "signature": "(plugin: 'Plugin') -> 'None'",
          "parameters": [
            {
              "name": "plugin",
              "annotation": "Plugin",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "livekit.agents.plugin"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.openai.STT": {
      "name": "STT",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.openai.stt",
      "bases": [
        "STT"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.openai.TTS": {
      "name": "TTS",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.openai.tts",
      "bases": [
        "TTS"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.silero.Plugin": {
      "name": "Plugin",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.agents.plugin",
      "bases": [
        "ABC"
      ],
      "methods": {
        "register_plugin": {
          "name": "register_plugin",
          "docstring": "No documentation available",
          "signature": "(plugin: 'Plugin') -> 'None'",
          "parameters": [
            {
              "name": "plugin",
              "annotation": "Plugin",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "livekit.agents.plugin"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.silero.SileroPlugin": {
      "name": "SileroPlugin",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.silero",
      "bases": [
        "Plugin"
      ],
      "methods": {
        "register_plugin": {
          "name": "register_plugin",
          "docstring": "No documentation available",
          "signature": "(plugin: 'Plugin') -> 'None'",
          "parameters": [
            {
              "name": "plugin",
              "annotation": "Plugin",
              "default": null,
              "kind": "POSITIONAL_OR_KEYWORD"
            }
          ],
          "return_annotation": "None",
          "module": "livekit.agents.plugin"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.silero.VAD": {
      "name": "VAD",
      "docstring": "Silero Voice Activity Detection (VAD) class.\n\nThis class provides functionality to detect speech segments within audio data using the Silero VAD model.",
      "module": "livekit.plugins.silero.vad",
      "bases": [
        "VAD"
      ],
      "methods": {
        "load": {
          "name": "load",
          "docstring": "Load and initialize the Silero VAD model.\n\nThis method loads the ONNX model and prepares it for inference. When options are not provided,\nsane defaults are used.\n\n**Note:**\n    This method is blocking and may take time to load the model into memory.\n    It is recommended to call this method inside your prewarm mechanism.\n\n**Example:**\n\n    ```python\n    def prewarm(proc: JobProcess):\n        proc.userdata[\"vad\"] = silero.VAD.load()\n\n\n    async def entrypoint(ctx: JobContext):\n        vad = (ctx.proc.userdata[\"vad\"],)\n        # your agent logic...\n\n\n    if __name__ == \"__main__\":\n        cli.run_app(WorkerOptions(entrypoint_fnc=entrypoint, prewarm_fnc=prewarm))\n    ```\n\nArgs:\n    min_speech_duration (float): Minimum duration of speech to start a new speech chunk.\n    min_silence_duration (float): At the end of each speech, wait this duration before ending the speech.\n    prefix_padding_duration (float): Duration of padding to add to the beginning of each speech chunk.\n    max_buffered_speech (float): Maximum duration of speech to keep in the buffer (in seconds).\n    activation_threshold (float): Threshold to consider a frame as speech.\n    sample_rate (Literal[8000, 16000]): Sample rate for the inference (only 8KHz and 16KHz are supported).\n    force_cpu (bool): Force the use of CPU for inference.\n    padding_duration (float | None): **Deprecated**. Use `prefix_padding_duration` instead.\n\nReturns:\n    VAD: An instance of the VAD class ready for streaming.\n\nRaises:\n    ValueError: If an unsupported sample rate is provided.",
          "signature": "(*, min_speech_duration: 'float' = 0.05, min_silence_duration: 'float' = 0.55, prefix_padding_duration: 'float' = 0.5, max_buffered_speech: 'float' = 60.0, activation_threshold: 'float' = 0.5, sample_rate: 'Literal[8000, 16000]' = 16000, force_cpu: 'bool' = True, padding_duration: 'NotGivenOr[float]' = NOT_GIVEN) -> 'VAD'",
          "parameters": [
            {
              "name": "min_speech_duration",
              "annotation": "float",
              "default": "0.05",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "min_silence_duration",
              "annotation": "float",
              "default": "0.55",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "prefix_padding_duration",
              "annotation": "float",
              "default": "0.5",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "max_buffered_speech",
              "annotation": "float",
              "default": "60.0",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "activation_threshold",
              "annotation": "float",
              "default": "0.5",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "sample_rate",
              "annotation": "Literal[8000, 16000]",
              "default": "16000",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "force_cpu",
              "annotation": "bool",
              "default": "True",
              "kind": "KEYWORD_ONLY"
            },
            {
              "name": "padding_duration",
              "annotation": "NotGivenOr[float]",
              "default": "NOT_GIVEN",
              "kind": "KEYWORD_ONLY"
            }
          ],
          "return_annotation": "VAD",
          "module": "livekit.plugins.silero.vad"
        }
      },
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    },
    "livekit.plugins.silero.VADStream": {
      "name": "VADStream",
      "docstring": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "module": "livekit.plugins.silero.vad",
      "bases": [
        "VADStream"
      ],
      "methods": {},
      "properties": {},
      "class_methods": {},
      "static_methods": {}
    }
  },
  "functions": {
    "livekit.agents.function_tool": {
      "name": "function_tool",
      "docstring": "No documentation available",
      "signature": "(f: 'F | Raw_F | None' = None, *, name: 'str | None' = None, description: 'str | None' = None, raw_schema: 'RawFunctionDescription | dict[str, Any] | None' = None) -> 'FunctionTool | RawFunctionTool | Callable[[F], FunctionTool] | Callable[[Raw_F], RawFunctionTool]'",
      "parameters": [
        {
          "name": "f",
          "annotation": "F | Raw_F | None",
          "default": "None",
          "kind": "POSITIONAL_OR_KEYWORD"
        },
        {
          "name": "name",
          "annotation": "str | None",
          "default": "None",
          "kind": "KEYWORD_ONLY"
        },
        {
          "name": "description",
          "annotation": "str | None",
          "default": "None",
          "kind": "KEYWORD_ONLY"
        },
        {
          "name": "raw_schema",
          "annotation": "RawFunctionDescription | dict[str, Any] | None",
          "default": "None",
          "kind": "KEYWORD_ONLY"
        }
      ],
      "return_annotation": "FunctionTool | RawFunctionTool | Callable[[F], FunctionTool] | Callable[[Raw_F], RawFunctionTool]",
      "module": "livekit.agents.llm.tool_context"
    },
    "livekit.agents.get_job_context": {
      "name": "get_job_context",
      "docstring": "No documentation available",
      "signature": "() -> 'JobContext'",
      "parameters": [],
      "return_annotation": "JobContext",
      "module": "livekit.agents.job"
    },
    "livekit.agents.llm.find_function_tools": {
      "name": "find_function_tools",
      "docstring": "No documentation available",
      "signature": "(cls_or_obj: 'Any') -> 'list[FunctionTool | RawFunctionTool]'",
      "parameters": [
        {
          "name": "cls_or_obj",
          "annotation": "Any",
          "default": null,
          "kind": "POSITIONAL_OR_KEYWORD"
        }
      ],
      "return_annotation": "list[FunctionTool | RawFunctionTool]",
      "module": "livekit.agents.llm.tool_context"
    },
    "livekit.agents.llm.function_tool": {
      "name": "function_tool",
      "docstring": "No documentation available",
      "signature": "(f: 'F | Raw_F | None' = None, *, name: 'str | None' = None, description: 'str | None' = None, raw_schema: 'RawFunctionDescription | dict[str, Any] | None' = None) -> 'FunctionTool | RawFunctionTool | Callable[[F], FunctionTool] | Callable[[Raw_F], RawFunctionTool]'",
      "parameters": [
        {
          "name": "f",
          "annotation": "F | Raw_F | None",
          "default": "None",
          "kind": "POSITIONAL_OR_KEYWORD"
        },
        {
          "name": "name",
          "annotation": "str | None",
          "default": "None",
          "kind": "KEYWORD_ONLY"
        },
        {
          "name": "description",
          "annotation": "str | None",
          "default": "None",
          "kind": "KEYWORD_ONLY"
        },
        {
          "name": "raw_schema",
          "annotation": "RawFunctionDescription | dict[str, Any] | None",
          "default": "None",
          "kind": "KEYWORD_ONLY"
        }
      ],
      "return_annotation": "FunctionTool | RawFunctionTool | Callable[[F], FunctionTool] | Callable[[Raw_F], RawFunctionTool]",
      "module": "livekit.agents.llm.tool_context"
    },
    "livekit.agents.llm.is_function_tool": {
      "name": "is_function_tool",
      "docstring": "No documentation available",
      "signature": "(f: 'Callable[..., Any]') -> 'TypeGuard[FunctionTool]'",
      "parameters": [
        {
          "name": "f",
          "annotation": "Callable[..., Any]",
          "default": null,
          "kind": "POSITIONAL_OR_KEYWORD"
        }
      ],
      "return_annotation": "TypeGuard[FunctionTool]",
      "module": "livekit.agents.llm.tool_context"
    },
    "livekit.agents.llm.is_raw_function_tool": {
      "name": "is_raw_function_tool",
      "docstring": "No documentation available",
      "signature": "(f: 'Callable[..., Any]') -> 'TypeGuard[RawFunctionTool]'",
      "parameters": [
        {
          "name": "f",
          "annotation": "Callable[..., Any]",
          "default": null,
          "kind": "POSITIONAL_OR_KEYWORD"
        }
      ],
      "return_annotation": "TypeGuard[RawFunctionTool]",
      "module": "livekit.agents.llm.tool_context"
    },
    "livekit.plugins.openai.create_embeddings": {
      "name": "create_embeddings",
      "docstring": "No documentation available",
      "signature": "(*, input: 'list[str]', model: 'models.EmbeddingModels' = 'text-embedding-3-small', dimensions: 'int | None' = None, api_key: 'str | None' = None, http_session: 'aiohttp.ClientSession | None' = None) -> 'list[EmbeddingData]'",
      "parameters": [
        {
          "name": "input",
          "annotation": "list[str]",
          "default": null,
          "kind": "KEYWORD_ONLY"
        },
        {
          "name": "model",
          "annotation": "models.EmbeddingModels",
          "default": "text-embedding-3-small",
          "kind": "KEYWORD_ONLY"
        },
        {
          "name": "dimensions",
          "annotation": "int | None",
          "default": "None",
          "kind": "KEYWORD_ONLY"
        },
        {
          "name": "api_key",
          "annotation": "str | None",
          "default": "None",
          "kind": "KEYWORD_ONLY"
        },
        {
          "name": "http_session",
          "annotation": "aiohttp.ClientSession | None",
          "default": "None",
          "kind": "KEYWORD_ONLY"
        }
      ],
      "return_annotation": "list[EmbeddingData]",
      "module": "livekit.plugins.openai.embeddings"
    }
  },
  "examples": {}
}